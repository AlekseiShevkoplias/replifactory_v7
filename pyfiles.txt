Repository: replifactory_v7

File Tree:
└── flask_app/__init__.py
└── flask_app/experiment/ModelBasedCulture/__init__.py
└── flask_app/experiment/ModelBasedCulture/culture_growth_model.py
└── flask_app/experiment/ModelBasedCulture/model_equations.py
└── flask_app/experiment/ModelBasedCulture/model_equations_plotting.py
└── flask_app/experiment/ModelBasedCulture/morbidostat_updater.py
└── flask_app/experiment/ModelBasedCulture/real_culture_wrapper.py
└── flask_app/experiment/ModelBasedCulture/tests/test_model.py
└── flask_app/experiment/ModelBasedCulture/tests/updater_objective_minimize.py
└── flask_app/experiment/__init__.py
└── flask_app/experiment/culture.py
└── flask_app/experiment/database_models.py
└── flask_app/experiment/experiment.py
└── flask_app/experiment/export.py
└── flask_app/experiment/growth_rate.py
└── flask_app/experiment/plot.py
└── flask_app/migrations/env.py
└── flask_app/migrations/versions/84622d1915e6_add_rpm_column_to_culturedata.py
└── flask_app/minimal_device/__init__.py
└── flask_app/minimal_device/adc.py
└── flask_app/minimal_device/base_device.py
└── flask_app/minimal_device/device_data.py
└── flask_app/minimal_device/dilution.py
└── flask_app/minimal_device/eeprom.py
└── flask_app/minimal_device/lasers.py
└── flask_app/minimal_device/led.py
└── flask_app/minimal_device/loading.py
└── flask_app/minimal_device/od_sensor.py
└── flask_app/minimal_device/other.py
└── flask_app/minimal_device/pump.py
└── flask_app/minimal_device/pwm.py
└── flask_app/minimal_device/stepper.py
└── flask_app/minimal_device/stirrers.py
└── flask_app/minimal_device/test_hardware.py
└── flask_app/minimal_device/thermometers.py
└── flask_app/minimal_device/valves.py
└── flask_app/minimal_device/workers.py
└── flask_app/notebook.py
└── flask_app/routes/__init__.py
└── flask_app/routes/device_routes.py
└── flask_app/routes/experiment_routes.py
└── flask_app/routes/service_routes.py
└── flask_app/server.py
└── flask_app/tests/__init__.py
└── flask_app/tests/debug/debug_device.py
└── flask_app/tests/debug/erase_memory.py
└── flask_app/tests/device_test.py
└── flask_app/tests/experiment_test.py
└── flask_app/tests/old_tests/culture_test.py
└── flask_app/tests/old_tests/culture_tests.py
└── flask_app/tests/old_tests/culture_update_test.py
└── flask_app/tests/old_tests/db _update_test.py
└── flask_app/tests/old_tests/device_test.py
└── flask_app/tests/old_tests/experiment_routes_tests.py
└── flask_app/tests/old_tests/plot_test.py
└── flask_app/tests/old_tests/service_routes_tests.py
└── flask_app/tests/old_tests/tests.py
└── flask_app/tests/simulation_test.py
└── scripts/update_and_restart_experiment.py
└── vue/dist/sphinx/conf.py
└── vue/public/sphinx/conf.py
└── vue/src/server/url_into_sheet.py

File Contents:

--- flask_app/__init__.py ---


--- flask_app/experiment/ModelBasedCulture/__init__.py ---


--- flask_app/experiment/ModelBasedCulture/culture_growth_model.py ---
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import numpy as np

from .model_equations import dose_effective, mu_effective, adaptation_rate

culture_growth_model_default_parameters = {
    'initial_population': 0.05,
    'doubling_time_mins': 20,
    'carrying_capacity': 0.9,
    'mu_min': -0.1,
    'ic50_initial': 5,
    'ic10_ic50_ratio': 0.5,
    'dose_effective_slope_width_mins': 120,
    'time_lag_drug_effect_mins': 30,
    'adaptation_rate_max': 0.08,
    'adaptation_rate_ic10_ic50_ratio': 0.8,
}


def get_simulation_efficiency(model):
    # print("d50: {}, dilution_count: {}, effective_dose: {}".format(model.ic50_initial, len(model.doses), model.effective_dose))
    volume_used = len(model.doses) * 10
    ic50_fold_change = model.ic50s[-1][0] / model.ic50s[0][0]
    total_time = (model.population[-1][1] - model.population[0][1]).total_seconds() / 3600
    # print("Volume Used: {:.1f} ml, IC50 fold change: {:.2f}".format(volume_used, ic50_fold_change))
    volume_per_ic50_doubling = volume_used / np.log2(ic50_fold_change)
    # print("Volume per IC50 doubling: {:.1f} ml".format(volume_per_ic50_doubling))
    time_per_ic50_doubling = total_time / np.log2(ic50_fold_change)
    # print("Time per IC50 doubling: {:.1f} hours".format(total_time / np.log2(ic50_fold_change)))
    return volume_per_ic50_doubling, time_per_ic50_doubling


class CultureGrowthModel:
    def __init__(self, **kwargs):
        defaults = culture_growth_model_default_parameters
        # Update defaults with any overrides provided at initialization
        defaults.update(kwargs)
        # Assign all default values to instance variables
        for key, value in defaults.items():
            setattr(self, key, value)

        # Calculate maximum growth rate from doubling time
        self.mu_max = np.log(2) / (self.doubling_time_mins / 60)
        self._initialize_model_state()
        self.updater = None

    def _initialize_model_state(self):
        self.time_current = datetime.now()
        self.population = []
        self.generations = []
        self.doses = []
        self.effective_doses = []
        self.ic50s = [(self.ic50_initial, self.time_current)]
        self.effective_growth_rates = []
        self.adaptation_rates = []

    @property
    def growth_rate(self):
        return self.effective_growth_rates[-1][0] if self.effective_growth_rates else 0

    @property
    def first_od_timestamp(self):
        if not self.population:
            print("WARNING: Getting first OD timestamp without population data")
        return self.population[0][1] if self.population else self.time_current

    def calculate_effective_dose(self, time_current):
        """
        Calculate the effective dose of the drug at the current time, taking into account the doses added,
        the time since each addition and the lag time before the drug reaches half of its effectiveness.
        """
        if not self.effective_doses:
            current_effective_dose = self.updater.pump1_stock_drug_concentration
            self.effective_doses.append((current_effective_dose, self.time_current))
        effective_dose = self.effective_doses[0][0]  # Initial effective dose
        initial_equilibrium_dose = 0
        added_doses = np.diff([initial_equilibrium_dose]+[dose[0] for dose in self.doses])
        dilution_times = [dose[1] for dose in self.doses[0:]]
        # print(added_doses)
        for added_dose, dilution_time in zip(added_doses, dilution_times):
            if added_dose == 0:
                continue
            time_since_addition_hrs = (time_current - dilution_time).total_seconds() / 3600.0  # Convert to hours
            effective_dose += dose_effective(added_dose, self.time_lag_drug_effect_mins / 60,
                                             time_since_addition_hrs, self.dose_effective_slope_width_mins / 60)  # Assuming lag_time is in minutes
            # print("Effective Dose at time {}: {}".format(time_current, effective_dose))
        return effective_dose

    def simulate_experiment_minute(self):
        """
        Simulate one step of culture growth.
        Calculate:
            - The effective dose of the drug
            - The effective growth rate of the culture
            - The new population size
            - The adaptation rate
        Append new values to self data lists.
        Dilute the culture if needed.
        """
        effective_dose = self.calculate_effective_dose(self.time_current)
        self.effective_doses.append((effective_dose, self.time_current))
        if self.population:
            effective_growth_rate = mu_effective(effective_dose, self.mu_min, self.mu_max, self.ic10_ic50_ratio,
                                                 self.ic50s[-1][0], self.population[-1][0], self.carrying_capacity)
            self.effective_growth_rates.append((effective_growth_rate, self.time_current))

        if effective_dose > 0:
            adapt_rate = adaptation_rate(effective_dose, self.adaptation_rate_max, self.ic50s[-1][0],
                                         self.ic10_ic50_ratio,
                                         self.adaptation_rate_ic10_ic50_ratio)
            self.adaptation_rates.append((adapt_rate, self.time_current))

            ic50 = self.ic50s[-1][0] * np.exp(adapt_rate / 60)
            self.ic50s.append((ic50, self.time_current))
        if not self.population:
            new_population = self.initial_population
        else:
            new_population = self.population[-1][0] * np.exp(effective_growth_rate / 60)
        self.population.append((new_population, self.time_current))
        self.updater.update(model=self)

    def dilute_culture(self, target_dose=0, dilution_factor=None):
        """
        Dilute the culture and adjust the drug dose based on the dilution factor and the added dose.
        """
        if dilution_factor is None:
            dilution_factor = self.updater.dilution_factor
        current_volume = self.updater.volume_vial
        added_volume = current_volume * (dilution_factor - 1)
        total_volume = current_volume + added_volume

        if total_volume > 30:
            raise ValueError("Total volume during dilution cannot exceed 30 ml")

        stock1_concentration = self.updater.pump1_stock_drug_concentration
        stock2_concentration = self.updater.pump2_stock_drug_concentration
        if not self.doses:
            current_dose = stock1_concentration
        else:
            current_dose = self.doses[-1][0]

        only_pump1_resulting_dose = (current_dose * current_volume + stock1_concentration * added_volume) / total_volume
        only_pump2_resulting_dose = (current_dose * current_volume + stock2_concentration * added_volume) / total_volume
        min_dose, max_dose = min(only_pump1_resulting_dose, only_pump2_resulting_dose), max(only_pump1_resulting_dose, only_pump2_resulting_dose)
        target_dose = min(max_dose, max(min_dose, target_dose))

        added_dose = target_dose - current_dose
        new_dose = current_dose + added_dose
        self.doses.append((new_dose, self.time_current))
        self.population[-1] = (self.population[-1][0] / dilution_factor, self.time_current)
        generation_number = np.log2(dilution_factor)
        if self.generations:
            generation_number += self.generations[-1][0]
        self.generations.append((generation_number, self.time_current))

    def check_parameters(self):
        if self.initial_population < 0:
            raise ValueError("Initial population cannot be negative")
        if self.doubling_time_mins < 0:
            raise ValueError("Doubling time cannot be negative")
        if self.carrying_capacity < 0:
            raise ValueError("Carrying capacity cannot be negative")
        if self.ic50_initial < 0:
            raise ValueError("Initial IC50 cannot be negative")
        if self.ic10_ic50_ratio <= 0:
            raise ValueError("IC10/IC50 ratio must be greater than 0")
        if self.dose_effective_slope_width_mins <= 0:
            raise ValueError("Dose effective slope width must be greater than 0")
        if self.time_lag_drug_effect_mins < 0:
            raise ValueError("Time lag drug effect cannot be negative")
        if self.adaptation_rate_max < 0:
            raise ValueError("Maximum adaptation rate cannot be negative")

    def simulate_experiment(self, simulation_hours=48):
        """
        Simulate bacterial growth over a specified period, with a change in drug dose after 3 dilutions.
        """
        self.check_parameters()
        for t in range(1, simulation_hours * 60):
            self.time_current += timedelta(minutes=1)
            self.simulate_experiment_minute()

    def plot_parameters(self):
        from .model_equations import dose_effective, mu_effective, adaptation_rate
        from .model_equations_plotting import plot_dose_effective, plot_mu_effective, \
            plot_adaptation_rate

        plot_dose_effective(model=self, dose_effective=dose_effective)
        plot_mu_effective(model=self, mu_effective=mu_effective)
        plot_adaptation_rate(model=self, adaptation_rate=adaptation_rate)

    def plot_simulation(self, simulation_hours):
        self.simulate_experiment(simulation_hours)

        # population, doses, effective_growth_rates, ic50s, adaptation_rates, effective_doses
        times = [p[1] for p in self.population]
        ods = [p[0] for p in self.population]
        growth_rates, times_growth_rates = zip(*self.effective_growth_rates)
        d50_values, times_d50s = zip(*self.ic50s)
        doses_values, times_doses = zip(*self.doses)
        adaptation_rates = self.adaptation_rates
        effective_dose_values, times_effective_doses = zip(*self.effective_doses)
        generations, times_generations = zip(*self.generations)



        # Plot the main graph
        fig, ax1 = plt.subplots(figsize=(16, 9))
        ax1.plot(times, ods, "ko:", label='Bacteria Population', alpha=0.5)
        ax1.set_ylabel('Optical Density')

        # Setup Effective Growth Rate secondary y-axis (ax3)
        ax3 = ax1.twinx()
        ax3.spines['right'].set_position(('outward', 60))  # Pushes ax3 to the right
        ax3.plot(times_growth_rates, growth_rates, 'o-', color='blue', label='Effective Growth Rate')
        ax3.set_ylabel('Effective Growth Rate', color='blue')
        ax3.tick_params(axis='y', colors='blue')

        # Combine IC50 and Doses on the same secondary y-axis (ax4) on the left
        ax4 = ax1.twinx()
        ax4.spines["right"].set_visible(False)  # Hide the right spine
        ax4.yaxis.set_label_position('left')
        ax4.yaxis.set_ticks_position('left')
        ax4.spines["left"].set_position(('outward', 60))  # Adjust to avoid overlap
        ax4.set_ylabel('Dose / IC50', color='green')

        ax4.plot(times_d50s, d50_values, ':', color='green', label='IC50')

        # add point at the end to make step all the way to the right
        doses_values += (doses_values[-1],)
        times_doses += (times[-1],)

        ax4.step(times_doses, doses_values, "-", color='green', label='Dose', where='post', linewidth=1)
        ax4.tick_params(axis='y', colors='green', labelleft=True)
        ax4.step(times_effective_doses, effective_dose_values, "--", color='green', label='Effective Dose', where='post',linewidth=3)

        # Setup Adaptation Rate secondary y-axis (ax5)
        if len(adaptation_rates)>0:
            adaptation_values, times_adaptation = zip(*adaptation_rates)

            ax5 = ax1.twinx()
            ax5.plot(times_adaptation, adaptation_values, 'o-', color='xkcd:violet', label='Adaptation Rate [1/h]', markersize=2, alpha=0.5)
            ax5.set_ylabel('Adaptation Rate', color='xkcd:violet')
            ax5.tick_params(axis='y', colors='xkcd:violet')

        # Plot generations in red
        ax6 = ax1.twinx()
        ax6.spines["right"].set_visible(False)
        ax6.yaxis.set_label_position('left')
        ax6.yaxis.set_ticks_position('left')
        ax6.spines["left"].set_position(('outward', 110))
        ax6.set_ylabel('Generations', color='red')
        ax6.plot(times_generations, generations, 'ro-', label='Generations', alpha=0.5)
        ax6.tick_params(axis='y', colors='red')

        ax1.set_title('Model of adaptive evolution experiment')
        # fig.legend(loc='upper left', bbox_to_anchor=(0.1, 0.9))
        fig.legend()
        plt.show()

--- flask_app/experiment/ModelBasedCulture/model_equations.py ---
import numpy as np


def mu(dose, mu_min, mu_max, ic10_ic50_ratio, ic50):
    """
    Calculate the growth rate of the bacteria as a function of the drug dose.
    dose: drug dose
    mu_max: maximum growth rate [1/hour]
    ic10_ic50_ratio: ratio of ic10 to ic50, describing the steepness of the growth rate response to the drug dose
    d50: dose at which the growth rate is half of mu_max (ic50)
    return: growth rate
    """

    dose_ic10 = ic50 * ic10_ic50_ratio
    k_mu = np.log(9) / (ic50 - dose_ic10)
    return mu_min + (mu_max / (1 + np.exp(-k_mu * (ic50 - dose))))


def dose_effective(dose, lag_time_hrs, time_since_addition_hrs, slope_width_hrs):
    """
    Calculate the effective dose of the drug, taking into account the lag time before the drug takes effect
    and modeling the increase in effective dose with a sigmoid function based on a specified slope_width_hrs.

    Parameters:
    - dose: The total dose of the drug.
    - lag_time_hrs: The lag time in hours before the drug reaches half of its effectiveness.
    - time_since_addition_hrs: The elapsed time in hours since the drug was administered.
    - slope_width_hrs: Describes the width of the transition from 5% to 95% effectiveness.

    Returns:
    - The effective dose, varying between 0 and the total dose.
    """
    # Calculate the value of k using the slope_width_hrs to achieve the desired 5% to 95% transition
    k = np.log(19) / (0.5 * slope_width_hrs)  # Based on solving the sigmoid function for 5% and 95%

    # Adjust x to shift the sigmoid curve so that the inflection point is at the lag time
    x_value = (time_since_addition_hrs - lag_time_hrs)

    # Apply the sigmoid function to calculate the effective dose
    effective_dose = dose / (1 + np.exp(-k * x_value))
    # print("time_since_addition_hrs: {}, effective_dose: {}".format(time_since_addition_hrs, effective_dose))
    return effective_dose


def mu_effective(dose, mu_min, mu_max, ic10_ic50_ratio, ic50, population, carrying_capacity):
    """
    Calculate the effective growth rate of the bacteria, taking into account the drug dose,
    the carrying capacity, and the current population size.
    dose: drug dose
    mu_max: maximum growth rate
    ic10_ic50_ratio: ratio of ic10 to ic50, describing the steepness of the growth rate response to the drug dose
    ic50: dose at which the growth rate is half of mu_max (ic50)
    population: current population size
    carrying_capacity: maximum population size
    return: effective growth rate
    """
    # print("dose: {}, mu_max: {}, ic10_ic50_ratio: {}, ic50: {}, population: {}, carrying_capacity: {}".format(dose, mu_max, ic10_ic50_ratio, ic50, population, carrying_capacity))
    return mu_min + mu(dose, 0, mu_max, ic10_ic50_ratio, ic50) * (1 - population / carrying_capacity)


def adaptation_rate(dose, adaptation_rate_max, ic50, ic10_ic50_ratio, adaptation_rate_ic10_ic50_ratio):
    """
    Calculate the adaptation rate as a function of the drug dose using a Gaussian curve modified by a
    coefficient representing the height of the curve at a dose equal to 50% of ic50.

    Parameters:
    - dose: Antibiotic dose.
    - adaptation_rate_max: The maximum adaptation rate, which occurs at ic50.
    - ic50: Dose at which the growth rate is half of mu_max (IC50).
    - ic10_ic50_ratio: Ratio of ic10 to ic50, describing the steepness of the growth rate response to the drug dose.
    - adaptation_rate_ic10_ic50_ratio: ratio of the adaptation rate at ic10 to the adaptation rate at ic50,
    describing the steepness of the adaptation rate response to the drug dose.

    Returns:
    - Adaptation rate based on the given dose and curve parameters.
    """

    # Calculate k_adapt dynamically based on height_at_50
    # We solve for k_adapt such that the Gaussian formula equals height_at_50 * adaptation_rate_max at dose = ic50 / 2
    ic10 = ic50 * ic10_ic50_ratio
    k_adapt = -np.log(adaptation_rate_ic10_ic50_ratio) / ((ic10 - ic50) ** 2)
    adapt_rate = adaptation_rate_max * np.exp(-k_adapt * ((dose - ic50) ** 2))
    return adapt_rate


--- flask_app/experiment/ModelBasedCulture/model_equations_plotting.py ---
import matplotlib.pyplot as plt
import numpy as np


def plot_mu(model=None, mu=None):
    if model is not None:
        mu_min, mu_max, ic10_ic50_ratio, ic50 = model.mu_min, model.mu_max, model.ic10_ic50_ratio, model.ic50_initial
        doses = np.linspace(0, ic50 * 4, 101)
    else:
        doses = np.linspace(0, 100, 101)
        mu_min, mu_max, ic10_ic50_ratio, ic50 = -0.1, 1, 0.1, 50

    # round all values to 2 decimal places
    mu_min, mu_max, ic10_ic50_ratio, ic50 = round(mu_min, 2), round(mu_max, 2), round(ic10_ic50_ratio, 2), round(ic50, 2)

    mu_values = mu(doses, mu_min = mu_min, mu_max=mu_max, ic10_ic50_ratio=ic10_ic50_ratio, ic50=ic50)

    plt.figure(figsize=(10, 6))
    plt.plot(doses, mu_values, label='Growth Rate')
    plt.xlabel('Antibiotic Dose')
    plt.ylabel('Growth Rate')
    plt.title('Effect of Antibiotic Dose on Bacterial Growth Rate')
    plt.legend()
    plt.grid(True)
    plt.show()


def plot_dose_effective(model=None, dose_effective=None):
    """
    Plot the effective antibiotic dose over time, taking into account the lag time before the drug takes effect.
    """
    dose = 100
    time_since_addition_hrs = np.linspace(0, 6, 100)

    plt.figure(figsize=(10, 6))
    if model is not None:
        lag_time_mins, slope_width_mins = model.time_lag_drug_effect_mins, model.dose_effective_slope_width_mins
        effective_doses = dose_effective(dose=dose, lag_time_hrs=model.time_lag_drug_effect_mins / 60, time_since_addition_hrs=time_since_addition_hrs, slope_width_hrs=model.dose_effective_slope_width_mins/60)
        plt.plot(time_since_addition_hrs, effective_doses, label='Lag Time Constant = {} mins, Slope Width = {} mins'.format(lag_time_mins,
                                                                                       slope_width_mins), color='black', linewidth=2)

    for lag_time_mins in [30, 120]:
        for slope_width_mins in [30, 240]:
            effective_doses = dose_effective(dose, lag_time_mins / 60, time_since_addition_hrs,
                                             slope_width_hrs=slope_width_mins / 60)
            plt.plot(time_since_addition_hrs, effective_doses,
                     label='Lag Time Constant = {} mins, Slope Width = {} mins'.format(lag_time_mins,
                                                                                       slope_width_mins),alpha=0.3, linestyle='--')
    plt.xlabel('Time Since Drug Addition (hours)')
    plt.ylabel('Effective Dose (% actual dose)')
    plt.title('Drug effect lag afer addition')
    plt.legend()
    plt.grid(True)
    plt.show()


def plot_mu_effective(model=None, mu_effective=None):
    max_dose = 100 if model is None else model.ic50_initial * 4
    mu_max = 1 if model is None else round(model.mu_max, 2)
    mu_min = -0.1 if model is None else round(model.mu_min, 2)
    ic10_ic50_ratio = 0.9 if model is None else model.ic10_ic50_ratio
    ic50 = 50 if model is None else model.ic50_initial
    carrying_capacity = 2 if model is None else model.carrying_capacity

    plt.figure(figsize=(10, 6))

    doses = np.linspace(0, max_dose, 101)
    for population in [f * carrying_capacity for f in [0.1, 0.3, 0.6, 0.9]]:
        mu_values = mu_effective(doses, mu_min=mu_min, mu_max=mu_max, ic10_ic50_ratio=ic10_ic50_ratio, ic50=ic50,
                                 population=population, carrying_capacity=carrying_capacity)
        plt.plot(doses, mu_values, label='Effective Growth Rate (Population={:.3f})'.format(population))
    plt.axvline(x=ic50, color='red', linestyle='--', label='IC50 = {}'.format(ic50))
    plt.xlabel('Antibiotic Dose')
    plt.ylabel('Effective Growth Rate')
    plt.title('Effective Growth Rate of Bacteria with Antibiotic Dose and Population Size')
    if model is not None:
        plt.suptitle('IC50 = {}, mu_max = {}, ic10_ic50_ratio = {}, carrying_capacity = {}'.format(ic50, mu_max, ic10_ic50_ratio, carrying_capacity))
    plt.legend()
    plt.grid(True)
    plt.show()


def plot_adaptation_rate(model=None, adaptation_rate=None):
    """plot for different values of adaptation_rate_ic10_ic50_ratio"""
    ic50 = 23 if model is None else model.ic50_initial
    adaptation_rate_max = 0.05 if model is None else model.adaptation_rate_max
    ic10_ic50_ratio = 0.8 if model is None else model.ic10_ic50_ratio
    ic10 = ic50 * ic10_ic50_ratio

    doses = np.linspace(0, ic50*2, 100)

    plt.figure(figsize=(10, 6))
    if model is not None:
        adapt_rates = adaptation_rate(doses, adaptation_rate_max, ic50, ic10_ic50_ratio, model.adaptation_rate_ic10_ic50_ratio)
        plt.plot(doses, adapt_rates, label='adaptation_rate_ic10_ic50_ratio = {}'.format(model.adaptation_rate_ic10_ic50_ratio), color='black')
    else:
        for adaptation_rate_ic10_ic50_ratio in [0.1, 0.5, 0.95, 0.99]:
            adapt_rates = adaptation_rate(doses, adaptation_rate_max, ic50, ic10_ic50_ratio,
                                          adaptation_rate_ic10_ic50_ratio)
            plt.plot(doses, adapt_rates,
                     label='adaptation_rate_ic10_ic50_ratio = {}'.format(adaptation_rate_ic10_ic50_ratio))

    plt.axvline(x=ic50, color='red', linestyle='--', label='IC50 = {}'.format(ic50))
    plt.axvline(x=ic10, color='red', linestyle='--', alpha=0.5, label='IC10 = {}'.format(ic10))
    plt.xlabel('Effective Antibiotic Dose')
    plt.ylabel('Adaptation Rate [1/hour]')
    plt.title('Effect of Antibiotic Dose on Adaptation Rate (IC50 = {})'.format(ic50))
    plt.legend()
    plt.grid(True)
    plt.show()

--- flask_app/experiment/ModelBasedCulture/morbidostat_updater.py ---
from datetime import timedelta
from pprint import pprint
import numpy as np

morbidostat_updater_default_parameters = {
    'volume_vial': 12,  # Volume of the vial in mL (liquid volume under waste needle)
    'pump1_stock_drug_concentration': 0,  # Concentration of the drug in the pump 1 stock bottle
    'pump2_stock_drug_concentration': 100,  # Concentration of the drug in the pump 2 stock bottle
    'dose_initialization': 3,  # Initial dose added to the culture immediately when the experiment starts. -1 to disable

    'dilution_factor': 1.6,  # Factor by which the population is reduced during dilution
    'od_dilution_threshold': 0.3,  # OD at which dilution occurs, -1 to disable OD triggered dilution. -1 to disable OD triggered dilution
    'delay_dilution_max_hours': 4,    # Maximum time between dilutions. Exact time if there are no other dilution triggers. -1 to disable time triggered dilution

    'dilution_number_first_drug_addition': 2,  # Dilution number at which dose_first_drug_addition is added. -1 to disable drug addition
    'dose_first_drug_addition': 1,  # Initial drug dose resulting in the vial at the first dilution triggered by OD or time
    'dose_increase_factor': 2,  # Factor by which the dose is increased at stress increases (new_dose = old_dose * factor + amount)
    'dose_increase_amount': 0,  # Amount by which the dose is increased at stress increases (new_dose = old_dose * factor + amount)

    'threshold_od_min_increase_stress': 0.1,  # Minimum OD for stress increase (increase dose if OD is higher)
    'threshold_growth_rate_increase_stress': 0.15,  # Minimum growth rate for stress increase (increase dose if growth rate is higher)
    'threshold_growth_rate_decrease_stress': -0.1,  # Maximum growth rate for rescue dilution (rescue if growth rate is lower)
    'delay_stress_increase_min_generations': 2,  # Minimum number of generations between stress increases.
    'postfill': 0, # Whether to add media before pumping waste (1) or pump waste before adding media (0)
}


class MorbidostatUpdater:
    """
    Class to update the culture based on the morbidostat algorithm.
    The update function will dilute the culture at a specified population size (OD) threshold.
    If the growth rate is too high, the drug dose will be increased.
    If the growth rate is too low, the culture will be rescued by diluting it to reduce the drug concentration,
    irrespective of the population size.
    """

    def __init__(self, **kwargs):
        defaults = morbidostat_updater_default_parameters.copy()
        defaults.update(kwargs)
        for key, value in defaults.items():
            setattr(self, key, value)
        self.status_dict = {}

    def is_time_to_increase_stress(self, model):
        """
        Check if it is time to increase stress. Conditions:
        - OD is above threshold
        - Growth rate is above threshold
        - Sufficient generations have passed since last dose change
        - Stress increase is not disabled
        - At least one dilution has been made
        """
        if -1 in [self.threshold_growth_rate_increase_stress, self.delay_stress_increase_min_generations]:
            self.status_dict["time_to_increase_stress"] = "Stress increase disabled"
            return False
        if len(model.doses)<1:
            self.status_dict["time_to_increase_stress"] = "No dilutions yet. Not increasing stress"
            return False
        last_dose_change_time = model.doses[0][1]
        current_dose = round(model.doses[-1][0], 3)
        for dose in model.doses:
            if round(dose[0], 3) != current_dose:
                last_dose_change_time = dose[1]
        # last_dose_change_time = [dose[1] for dose in model.doses if dose[0] != model.doses[-1][0]][-1]

        generations_at_last_dose_change = [gen[0] for gen in model.generations if gen[1] >= last_dose_change_time][0]
        generations_at_next_dilution = model.generations[-1][0] + np.log2(self.dilution_factor)
        generations_since_last_dose_change = generations_at_next_dilution - generations_at_last_dose_change
        enough_generations_have_passed = generations_since_last_dose_change > self.delay_stress_increase_min_generations
        if model.growth_rate is None:
            self.status_dict["time_to_increase_stress"] = "Growth rate is None. Not increasing stress"
            return False
        growing_fast_enough = model.growth_rate > self.threshold_growth_rate_increase_stress
        od_above_stress_increase_threshold = model.population[-1][0] > self.threshold_od_min_increase_stress

        if not od_above_stress_increase_threshold:
            self.status_dict["time_to_increase_stress"] = "OD %3f < threshold %3f for stress increase" % (model.population[-1][0], self.threshold_od_min_increase_stress)
            return False
        if not enough_generations_have_passed:
            self.status_dict["time_to_increase_stress"] = "%.2f generations since last dose change < %.2f threshold. Not increasing stress" % (generations_since_last_dose_change, self.delay_stress_increase_min_generations)
            return False
        if not growing_fast_enough:
            self.status_dict["time_to_increase_stress"] = "Growth rate %.3f < threshold %.3f. Not increasing stress" % (model.growth_rate, self.threshold_growth_rate_increase_stress)
            return False
        self.status_dict["time_to_increase_stress"] = "Growing fast enough and enough generations have passed since last stress increase. Increasing stress"
        return True

    def is_time_to_decrease_stress(self, model):
        """
        Check if it is time to decrease stress.
        """
        if -1 in [self.threshold_growth_rate_decrease_stress, self.delay_stress_increase_min_generations, self.dose_increase_factor]:
            self.status_dict["time_to_decrease_stress"] = "Stress decrease disabled"
            return False
        if model.growth_rate is None:
            self.status_dict["time_to_decrease_stress"] = "Growth rate is None. Not decreasing stress"
            return False
        if model.growth_rate > self.threshold_growth_rate_decrease_stress:
            self.status_dict["time_to_decrease_stress"] = "Growth rate %.3f > threshold %.3f. Not decreasing stress" % (model.growth_rate, self.threshold_growth_rate_decrease_stress)
            return False
        self.status_dict["time_to_decrease_stress"] = "Growth rate %.3f < threshold %.3f. Decreasing stress" % (model.growth_rate, self.threshold_growth_rate_decrease_stress)
        return True

    def dilute_and_adjust_dose(self, model):
        """
        Dilute the culture to the target dose and adjust the dose if necessary.
        """
        # check if time to initialize culture
        next_dilution_number = len(model.doses) + 1
        if next_dilution_number < self.dilution_number_first_drug_addition:
            if model.doses:
                target_dose = model.doses[-1][0]
                self.status_dict["dilution_message"] = "Dilution %d to dose %3f. Drug addition at dilution %d" % (next_dilution_number, target_dose, self.dilution_number_first_drug_addition)
            else:
                target_dose = self.pump1_stock_drug_concentration
                self.status_dict["dilution_message"] = "Dilution %d to dose %3f. Drug addition at dilution %d" % (next_dilution_number, target_dose, self.dilution_number_first_drug_addition)
            model.dilute_culture(target_dose)
            return

        # Check if time to add first drug dose
        if next_dilution_number == self.dilution_number_first_drug_addition:
            target_dose = self.dose_first_drug_addition
            self.status_dict["dilution_message"] = "First drug addition at dilution %d with dose %3f" % (next_dilution_number, target_dose)
            model.dilute_culture(target_dose)
            return

        if self.is_time_to_increase_stress(model):
            target_dose = self.calculate_increased_dose(model.doses[-1][0])
            self.status_dict["dilution_message"] = "Increasing dose to target %3f" % target_dose
            model.dilute_culture(target_dose)
            return

        if self.is_time_to_decrease_stress(model):
            self.status_dict["dilution_message"] = "Decreasing stress to pump1_stock_drug_concentration"
            model.dilute_culture(target_dose=self.pump1_stock_drug_concentration)
            return

        if len(model.doses) == 0:
            target_dose = self.dose_initialization
            self.status_dict["dilution_message"] = "Initializing culture to %3f" % target_dose
            model.dilute_culture(target_dose)
            return
        self.status_dict["dilution_message"] = "Diluting to last dose %3f" % model.doses[-1][0]
        model.dilute_culture(target_dose=model.doses[-1][0])

    def calculate_increased_dose(self, current_dose):
        """
        Calculate the new dose based on the current dose, dose increase factor, and dose increase amount.
        """
        new_dose = current_dose * self.dose_increase_factor + self.dose_increase_amount
        return round(new_dose, 3)

    def make_initialization_dilution_if_necessary(self, model):
        if self.dose_initialization < 0:
            self.status_dict["initialization_dilution"] = "Initialization disabled"
            return
        if len(model.doses) > 0:
            self.status_dict["initialization_dilution"] = "Initialization already done!"
            return

        self.status_dict["initialization_dilution"] = "Initialization enabled and no dilutions have been made yet - time to initialize!"
        target_dose = self.dose_initialization
        self.status_dict["dilution_message"] = "Initializing culture to %3f" % target_dose
        model.dilute_culture(target_dose)
        return True

    def make_time_triggered_dilution_if_necessary(self, model):
        if self.delay_dilution_max_hours < 0:
            self.status_dict["time_triggered_dilution"] = "Time triggered dilution disabled"
            return
        if len(model.doses) == 0:
            self.status_dict["time_triggered_dilution"] = "No dilutions made yet"
            return
        last_dilution_timestamp = model.doses[-1][1]
        hours_since_last_dilution = (model.time_current - last_dilution_timestamp).total_seconds() / 3600
        if hours_since_last_dilution < self.delay_dilution_max_hours:
            self.status_dict["time_triggered_dilution"] = "Hours since last dilution %.2f < max %.2f, not diluting" % (hours_since_last_dilution, self.delay_dilution_max_hours)
            return
        self.status_dict["time_triggered_dilution"] = "Hours since last dilution %.2f > max %.2f, diluting" % (hours_since_last_dilution, self.delay_dilution_max_hours)
        self.dilute_and_adjust_dose(model)
        return True

    def make_od_triggered_dilution_if_necessary(self, model):
        if self.od_dilution_threshold < 0:
            self.status_dict["od_triggered_dilution"] = "OD triggered dilution disabled"
            return
        if len(model.population) == 0:
            self.status_dict["od_triggered_dilution"] = "No OD measurements yet"
            return
        if model.population[-1][0] < self.od_dilution_threshold:
            self.status_dict["od_triggered_dilution"] = "OD %3f < threshold %3f" % (model.population[-1][0], self.od_dilution_threshold)
            return
        self.status_dict["od_triggered_dilution"] = "OD %3f >= threshold %3f, diluting" % (model.population[-1][0], self.od_dilution_threshold)
        self.dilute_and_adjust_dose(model)
        return True

    def must_wait_since_last_dilution(self, model):
        minutes_since_last_dilution = 4
        if len(model.doses) > 0:
            od_timestamp = model.population[-1][1]
            doses_timestamp = model.doses[-1][1]
            if od_timestamp < doses_timestamp + timedelta(minutes=minutes_since_last_dilution):
                self.status_dict["must_wait_since_last_dilution"] = "%d minutes have not passed since last dilution" % minutes_since_last_dilution
                return True
        self.status_dict["must_wait_since_last_dilution"] = "No, last OD data more than %d minutes since last dilution" % minutes_since_last_dilution
        return False

    def update(self, model):
        if self.must_wait_since_last_dilution(model):
            return
        if self.make_initialization_dilution_if_necessary(model):
            return
        if self.make_time_triggered_dilution_if_necessary(model):
            return
        self.make_od_triggered_dilution_if_necessary(model)


--- flask_app/experiment/ModelBasedCulture/real_culture_wrapper.py ---
from datetime import datetime
from pprint import pprint


class RealCultureWrapper:
    """
    Adapter class to convert the culture class to the model class.
    """
    def __init__(self, culture):
        self.culture = culture

    @property
    def population(self):
        # od_dict = {k: v for k, v in sorted(od_dict.items(), key=lambda item: item[0])}
        od_dict, mu_dict, rpm_dict = self.culture.get_last_ods_and_rpms(include_current=True)
        population = [(od, time) for time, od in od_dict.items()]
        return population

    @property
    def effective_growth_rates(self):
        od_dict, mu_dict, rpm_dict = self.culture.get_last_ods_and_rpms(include_current=True)
        effective_growth_rates = [(mu, time) for time, mu in mu_dict.items()]
        return effective_growth_rates

    @property
    def growth_rate(self):
        return self.culture.growth_rate

    @property
    def generations(self):
        generation_dict, concentration_dict = self.culture.get_last_generations()
        generations = [(generation, time) for time, generation in generation_dict.items()]
        return generations

    @property
    def doses(self):
        generation_dict, concentration_dict = self.culture.get_last_generations()
        doses = [(concentration, time) for time, concentration in concentration_dict.items()]
        return doses

    @property
    def time_current(self):
        return self.culture.time_current

    @property
    def first_od_timestamp(self):
        return self.culture.get_first_od_timestamp()

    def print_updater_status(self):
        # print time formatted as string
        print(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "Vial", self.culture.vial)
        pprint(self.culture.updater.status_dict)

    def dilute_culture(self, target_dose, dilution_factor=None):
        self.print_updater_status()
        if dilution_factor is None:
            dilution_factor = self.culture.updater.dilution_factor
        self.culture.make_culture_dilution(target_dose, dilution_factor)



# if isinstance(culture, CultureGrowthModel):
#     plotting_model = True
#     ods = {p[1]: p[0] for p in culture.population}
#     mus = {p[1]: p[0] for p in culture.effective_growth_rates}
#     concs = {p[1]: p[0] for p in culture.doses}
#     gens = {p[1]: p[0] for p in culture.generations}
#     rpms = {}
#     culture_parameters = {}
#     od_threshold = 1
#     vf = culture.updater.volume_vial
#     dilution_factor = culture.updater.dilution_factor
#     va = culture.updater.volume_vial * (dilution_factor - 1)
#     stress_decrease_delay_hrs = culture.updater.delay_stress_increase_min_generations  # TODO: Change this to hours
#     vial_number = 1
#     experiment_name = "Model"
#     culture_parameters = culture.updater.__dict__
# else:
#     # Extract data from real experiment
#     ods, mus, rpms = culture.get_last_ods_and_rpms(limit=limit)
#     gens, concs = culture.get_last_generations(limit=limit)
#     od_threshold = culture.parameters["od_threshold"]
#     vf = culture.parameters["volume_fixed"]
#     va = culture.parameters["volume_added"]
#     dilution_factor = (vf + va) / vf
#     stress_decrease_delay_hrs = culture.parameters["stress_decrease_delay_hrs"]
#     vial_number = culture.vial
#     experiment_name = culture.experiment.model.name
#     culture_parameters = culture.parameters.inner_dict


# from experiment.ModelBasedCulture.culture_growth_model import CultureGrowthModel
# from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater
#
# updater = MorbidostatUpdater()
# culture_model = CultureGrowthModel()

# culture_real = Culture()
# culture_wrapped =

--- flask_app/experiment/ModelBasedCulture/tests/test_model.py ---
from experiment.ModelBasedCulture.culture_growth_model import CultureGrowthModel, get_simulation_efficiency, culture_growth_model_default_parameters
from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater, morbidostat_updater_default_parameters


def score_model(model):
    model.simulate_experiment(simulation_hours=36)
    volume_per_ic50_doubling, time_per_ic50_doubling = get_simulation_efficiency(model)
    print(f"Volume per IC50 doubling: {volume_per_ic50_doubling} ml")
    print(f"Time per IC50 doubling: {time_per_ic50_doubling} hours")
    return time_per_ic50_doubling


updater = MorbidostatUpdater(**morbidostat_updater_default_parameters)
model = CultureGrowthModel(**culture_growth_model_default_parameters)
model.updater = updater
from experiment.plot import plot_culture

model.simulate_experiment(30)
fig = plot_culture(model)
import plotly.io as pio
pio.show(fig)

# model.plot_parameters()
# score_updater(model)


--- flask_app/experiment/ModelBasedCulture/tests/updater_objective_minimize.py ---
# Objective: Optimize the parameters of the MorbidostatUpdater class to minimize the time per IC50 doubling
# The optimization finds the best experiment parameters to maximize adaptation rate.
# Current growth model does not include effects induced by stationary phase.

from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater, morbidostat_updater_default_parameters
from experiment.ModelBasedCulture.culture_growth_model import CultureGrowthModel, get_simulation_efficiency, culture_growth_model_default_parameters
from test_model import score_model
from scipy.optimize import minimize

updater = MorbidostatUpdater(
    od_dilution_threshold=0.3,  # OD at which dilution occurs
    dilution_factor=1.5,  # Factor by which the population is reduced during dilution
    dilution_number_initial_dose=1,  # Number of dilutions before adding the drug
    dose_initial_added=5,  # Initial dose added to the culture
    dose_increase_factor=1.3,  # Factor by which the dose is increased at stress increases after the initial one
    threshold_growth_rate_increase_stress=0.15,  # Min growth rate threshold for stress increase
    threshold_growth_rate_decrease_stress=0.005,  # Max growth rate threshold for stress decrease
    delay_dilution_max_hours=6,  # Maximum time between dilutions
    delay_stress_increase_min_generations=3,  # Minimum generations between stress increases
    volume_vial=12,  # Volume of the vial
    pump1_stock_drug_concentration=0,  # Concentration of the drug in the pump 1 stock
    pump2_stock_drug_concentration=300)

updater = MorbidostatUpdater(**morbidostat_updater_default_parameters)
model = CultureGrowthModel(**culture_growth_model_default_parameters)
model.updater = updater

model.plot_simulation(simulation_hours=30)
model.plot_parameters()
# score_updater(model)

def objective(x):
    # Map the continuous parameters directly and convert discrete ones
    params = {
        'od_dilution_threshold': x[0],
        'dilution_factor': x[1],
        'initial_added_dose': x[2],
        'dose_increase_factor': x[3],
        'threshold_growth_rate_increase_stress': x[4],
        'threshold_growth_rate_decrease_stress': x[5],
        'delay_stress_increase_min_generations': int(x[6]),  # Discrete parameter
        'volume_vial': 12,  # Fixed parameter
        'pump1_stock_drug_concentration': 0,  # Fixed parameter
        'pump2_stock_drug_concentration': 300,  # Fixed parameter
        'dilutions_before_adding_drug': 1,  # Fixed parameter
        'delay_dilution_max_hours': 6  # Fixed parameter
    }
    model.updater = MorbidostatUpdater(**params)
    return score_model(model)

# Bounds for the parameters: ((min1, max1), (min2, max2), ...)
bounds = [
    (0.3, 0.9),  # od_dilution_threshold
    (1.2, 1.3),  # dilution_factor
    (5, 5),     # initial_added_dose
    (1.1, 1.4),  # dose_increase_factor
    (0.1, 0.12),  # threshold_growth_rate_increase_stress
    (0.001, 0.002),  # threshold_growth_rate_decrease_stress
    (2, 3)  # delay_stress_increase_min_generations, needs to be discrete but handled as continuous
]

# Initial guess
initial_guess = [0.6, 1.8, 5, 1.1, 0.15, 0.005, 3]

result = minimize(objective, initial_guess, method='L-BFGS-B', bounds=bounds, options={'disp': True, 'maxiter': 100})
print("Optimization Result:", result)

result_params = { 'od_dilution_threshold': result.x[0],
                    'dilution_factor': result.x[1],
                    'initial_added_dose': result.x[2],
                    'dose_increase_factor': result.x[3],
                    'threshold_growth_rate_increase_stress': result.x[4],
                    'threshold_growth_rate_decrease_stress': result.x[5],
                    'delay_stress_increase_min_generations': int(result.x[6]),
                    'volume_vial': 12,
                    'pump1_stock_drug_concentration': 0,
                    'pump2_stock_drug_concentration': 300,
                    'dilutions_before_adding_drug': 1,
                    'delay_dilution_max_hours': 6
                    }
print("Optimized Parameters:", result_params)
model.plot_simulation(simulation_hours=30)


--- flask_app/experiment/__init__.py ---


--- flask_app/experiment/culture.py ---
from datetime import datetime

import numpy as np
from experiment.database_models import CultureData, PumpData, CultureGenerationData
from experiment.growth_rate import calculate_last_growth_rate
from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater, morbidostat_updater_default_parameters
from minimal_device.dilution import make_device_dilution

from .ModelBasedCulture.culture_growth_model import CultureGrowthModel, culture_growth_model_default_parameters
from .ModelBasedCulture.real_culture_wrapper import RealCultureWrapper
from .plot import plot_culture
from .export import export_culture_csv, export_culture_plot_html
from copy import deepcopy


class AutoCommitDict:
    def __init__(self, initial_dict, db_session, experiment_model, vial):
        self.inner_dict = deepcopy(initial_dict)
        self.db_session = db_session
        self.experiment_model = experiment_model
        self.vial = vial

    def __getitem__(self, key):
        try:  # If the key is a number, return it as a number
            return float(self.inner_dict[key])
        except ValueError:  # If the key is a string, return it as a string
            return self.inner_dict[key]

    def __setitem__(self, key, value):
        self.inner_dict[key] = value
        parameters = deepcopy(self.experiment_model.parameters)
        parameters["cultures"][str(self.vial)] = self.inner_dict
        self.experiment_model.parameters = parameters
        self.db_session.commit()

    def __repr__(self):
        return repr(self.inner_dict)


class Culture:
    def __init__(self, experiment, vial, db):

        self.experiment = experiment
        self.vial = vial
        self.db = db

        self.od = None
        self.growth_rate = None

        self.drug_concentration = None
        self.generation = 0
        self.last_stress_increase_generation = 0
        self.last_dilution_time = None
        self.new_culture_data = None

        self.parameters = AutoCommitDict(
            experiment.model.parameters["cultures"][str(vial)],
            vial=vial,
            db_session=db.session,
            experiment_model=experiment.model)
        self.culture_growth_model = CultureGrowthModel()
        self.get_latest_data_from_db()
        self.updater = MorbidostatUpdater(**self.parameters.inner_dict)
        self.adapted_culture = RealCultureWrapper(self)

    @property
    def time_current(self):
        return datetime.now()

    def update(self):
        self.updater = MorbidostatUpdater(**self.parameters.inner_dict)
        self.adapted_culture = RealCultureWrapper(self)
        self.updater.update(self.adapted_culture)

    def plot(self, *args, **kwargs):
        return plot_culture(self, *args, **kwargs)

    def plot_predicted(self):
        self.updater = MorbidostatUpdater(**self.parameters.inner_dict)
        growth_parameters = self.experiment.model.parameters["growth_parameters"][str(self.vial)]
        self.culture_growth_model = CultureGrowthModel(**growth_parameters)
        self.culture_growth_model.updater = self.updater
        self.culture_growth_model.simulate_experiment()
        return plot_culture(self.culture_growth_model)

    def export_csv(self, output_directory=""):
        return export_culture_csv(self, output_directory=output_directory)

    def export_plot_html(self, output_directory=""):
        return export_culture_plot_html(self, output_directory=output_directory)

    def export_predicted_plot_html(self, output_directory=""):
        return export_culture_plot_html(self, output_directory=output_directory, predicted=True)

    def get_first_od_timestamp(self):
        culture_data = self.db.session.query(CultureData).filter(
            CultureData.experiment_id == self.experiment.model.id,
            CultureData.vial_number == self.vial
        ).order_by(CultureData.timestamp).first()
        return culture_data.timestamp

    def get_latest_data_from_db(self):
        # self.db.session.commit()
        # experiment_model = self.db.session.query(ExperimentModel).filter(
        #     ExperimentModel.id == self.experiment.model.id).first()
        # for k in experiment_model.parameters["cultures"][str(self.vial)].keys():
        #     self.parameters[k] = experiment_model.parameters["cultures"][str(self.vial)][k]

        self.parameters = AutoCommitDict(
            self.experiment.model.parameters["cultures"][str(self.vial)],
            vial=self.vial,
            db_session=self.experiment.db.session,
            experiment_model=self.experiment.model)


        # for k in self.experiment.model.parameters["cultures"][str(self.vial)].keys():
        #     self.parameters[k] = self.experiment.model.parameters["cultures"][str(self.vial)][k]

        # Get the last culture data for this culture
        latest_culture_data = self.db.session.query(CultureData).filter(
            CultureData.experiment_id == self.experiment.model.id,
            CultureData.vial_number == self.vial).order_by(CultureData.timestamp.desc()).first()

        # Get the last generation data for this culture
        latest_generation_data = self.db.session.query(CultureGenerationData).filter(
            CultureGenerationData.experiment_id == self.experiment.model.id,
            CultureGenerationData.vial_number == self.vial).order_by(CultureGenerationData.timestamp.desc()).first()
        if latest_generation_data is not None:
            self.generation = latest_generation_data.generation
            self.drug_concentration = latest_generation_data.drug_concentration
            self.last_dilution_time = latest_generation_data.timestamp

        if latest_culture_data is not None:
            self.od = latest_culture_data.od
            if latest_culture_data.growth_rate is not None:
                self.growth_rate = latest_culture_data.growth_rate
            else:
                latest_generation_data = self.db.session.query(CultureGenerationData).filter(
                    CultureGenerationData.experiment_id == self.experiment.model.id,
                    CultureGenerationData.vial_number == self.vial).order_by(
                    CultureGenerationData.timestamp.desc()).limit(20).all()
                for d in latest_generation_data:
                    if hasattr(d, "growth_rate"):
                        if d.growth_rate is not None:
                            self.growth_rate = d.growth_rate
                            break

        gen_data = self.db.session.query(CultureGenerationData).filter(
            CultureGenerationData.experiment_id == self.experiment.model.id,
            CultureGenerationData.vial_number == self.vial
        ).order_by(CultureGenerationData.timestamp).all()
        if len(gen_data) > 0:
            last_stress_increase_generation = gen_data[0].generation
            for i in range(len(gen_data) - 1):
                c1 = gen_data[i].drug_concentration
                c2 = gen_data[i + 1].drug_concentration
                if c2>c1:
                    if c1==0 or (c2-c1)/c1 > 0.01:
                        last_stress_increase_generation = gen_data[i + 1].generation
            self.last_stress_increase_generation = last_stress_increase_generation

    def get_data_at_timepoint(self, timepoint):
        self.parameters = AutoCommitDict(
            self.experiment.model.parameters["cultures"][str(self.vial)],
            vial=self.vial,
            db_session=self.experiment.db.session,
            experiment_model=self.experiment.model)

        # Get the last culture data for this culture
        latest_culture_data = self.db.session.query(CultureData).filter(
            CultureData.experiment_id == self.experiment.model.id,
            CultureData.vial_number == self.vial,
            CultureData.timestamp <= timepoint).order_by(CultureData.timestamp.desc()).first()

        # Get the last generation data for this culture
        latest_generation_data = self.db.session.query(CultureGenerationData).filter(
            CultureGenerationData.experiment_id == self.experiment.model.id,
            CultureGenerationData.vial_number == self.vial,
            CultureGenerationData.timestamp <= timepoint).order_by(CultureGenerationData.timestamp.desc()).first()

        if latest_generation_data is not None:
            self.generation = latest_generation_data.generation
            self.drug_concentration = latest_generation_data.drug_concentration
            self.last_dilution_time = latest_generation_data.timestamp

        if latest_culture_data is not None:
            self.od = latest_culture_data.od
            self.growth_rate = latest_culture_data.growth_rate

            # load latest drug increase
        gen_data = self.db.session.query(CultureGenerationData).filter(
            CultureGenerationData.experiment_id == self.experiment.model.id,
            CultureGenerationData.vial_number == self.vial,
            CultureGenerationData.timestamp <= timepoint
        ).order_by(CultureGenerationData.timestamp).all()
        if gen_data is not None:
            last_stress_increase_generation = 0
            for i in range(len(gen_data)-1):
                c1 = gen_data[i].drug_concentration
                c2 = gen_data[i + 1].drug_concentration
                if c2 > c1:
                    if c1 == 0 or (c2-c1)/c1 > 0.01:
                        last_stress_increase_generation = gen_data[i+1].generation
            self.last_stress_increase_generation = last_stress_increase_generation

    def log_od_and_rpm(self, od=None, rpm=None):
        self.od = od
        with self.experiment.app.app_context():
            self.new_culture_data = CultureData(
                experiment_id=self.experiment.model.id,
                vial_number=self.vial,
                od=od, growth_rate=None, rpm=rpm)

            self.db.session.add(self.new_culture_data)
            self.calculate_latest_growth_rate()
            if self.new_culture_data.growth_rate is not None:
                self.growth_rate = self.new_culture_data.growth_rate
            self.db.session.commit()
            self.get_latest_data_from_db()  # TODO: speed up by not querying the database again

    def log_pump_data(self, main_pump_volume, drug_pump_volume):
        with self.experiment.app.app_context():
            new_pump_data = PumpData(
                experiment_id=self.experiment.model.id,
                vial_number=self.vial,
                volume_main=main_pump_volume,
                volume_drug=drug_pump_volume,
                volume_waste=main_pump_volume+drug_pump_volume)
            self.db.session.add(new_pump_data)
            self.db.session.commit()
            self.get_latest_data_from_db()

            parameters = self.experiment.parameters
            parameters["stock_volume_main"] = float(parameters["stock_volume_main"]) - main_pump_volume
            parameters["stock_volume_drug"] = float(parameters["stock_volume_drug"]) - drug_pump_volume
            parameters["stock_volume_waste"] = float(parameters["stock_volume_waste"]
                                                     ) - main_pump_volume - drug_pump_volume
            self.experiment.parameters = parameters

    def log_generation(self, generation, concentration):
        self.generation = generation
        self.drug_concentration = concentration
        with self.experiment.app.app_context():
            new_generation_data = CultureGenerationData(
                experiment_id=self.experiment.model.id,
                vial_number=self.vial,
                generation=generation,
                drug_concentration=concentration,
            )
            self.db.session.add(new_generation_data)
            self.db.session.commit()
            self.get_latest_data_from_db()

    def _delete_all_records(self):
        self.db.session.query(CultureData).filter(CultureData.experiment_id == self.experiment.model.id,
                                                  CultureData.vial_number == self.vial).delete()
        self.db.session.query(PumpData).filter(PumpData.experiment_id == self.experiment.model.id,
                                               PumpData.vial_number == self.vial).delete()
        self.db.session.query(CultureGenerationData
                              ).filter(CultureGenerationData.experiment_id == self.experiment.model.id,
                                       CultureGenerationData.vial_number == self.vial).delete()
        self.db.session.commit()

    def calculate_latest_growth_rate(self):
        """
        reads last od values and calculates growth rate
        :return:
        """
        od_dict, _, _ = self.get_last_ods_and_rpms(limit=200, include_current=True, since_pump=True)
        t = np.array(list(int(dt.timestamp()) for dt in od_dict.keys()))

        # Ensure the OD values are floats before creating numpy array
        od = np.array([float(value) if value is not None else np.nan for value in od_dict.values()])

        # Check for NaN values
        if np.issubdtype(od.dtype, np.number):
            t = t[~np.isnan(od)]
            od = od[~np.isnan(od)]
            od[od <= 0] = 1e-6
            timepoint, mu, error = calculate_last_growth_rate(t, od)
            if np.isfinite(mu):
                self.new_culture_data.growth_rate = mu

    def get_last_ods_and_rpms(self, limit=100, include_current=False, since_pump=False):
        culture_data = self.db.session.query(CultureData).filter(
            CultureData.experiment_id == self.experiment.model.id,
            CultureData.vial_number == self.vial
        ).order_by(CultureData.timestamp.desc()).limit(limit).all()

        if since_pump and len(culture_data) > 0:
            if self.last_dilution_time is not None:
                culture_data = [data for data in culture_data if data.timestamp > self.last_dilution_time]

        od_dict = {data.timestamp: data.od for data in culture_data}
        mu_dict = {data.timestamp: data.growth_rate for data in culture_data}
        rpm_dict = {data.timestamp: data.rpm for data in culture_data}

        if include_current and self.new_culture_data is not None:
            od_dict[self.new_culture_data.timestamp] = self.new_culture_data.od  # Include current uncommitted data

        od_dict = {k: v for k, v in od_dict.items() if v is not None and k is not None}
        mu_dict = {k: v for k, v in mu_dict.items() if v is not None and k is not None}
        rpm_dict = {k: v for k, v in rpm_dict.items() if v is not None and k is not None}

        od_dict = {k: v for k, v in sorted(od_dict.items(), key=lambda item: item[0])}
        mu_dict = {k: v for k, v in sorted(mu_dict.items(), key=lambda item: item[0])}
        rpm_dict = {k: v for k, v in sorted(rpm_dict.items(), key=lambda item: item[0])}
        return od_dict, mu_dict, rpm_dict

    def get_last_generations(self, limit=1000):
        generation_data = self.db.session.query(CultureGenerationData).filter(
            CultureGenerationData.experiment_id == self.experiment.model.id,
            CultureGenerationData.vial_number == self.vial
        ).order_by(CultureGenerationData.timestamp.desc()).limit(limit).all()
        generation_dict = {data.timestamp: data.generation for data in generation_data}
        concentration_dict = {data.timestamp: data.drug_concentration for data in generation_data}

        generation_dict = {k: v for k, v in sorted(generation_dict.items(), key=lambda item: item[0])}
        concentration_dict = {k: v for k, v in sorted(concentration_dict.items(), key=lambda item: item[0])}
        return generation_dict, concentration_dict

    def make_culture_dilution(self, target_concentration=None, dilution_factor=None, current_volume=None, postfill=False):
        if self.drug_concentration is None:
            self.drug_concentration = self.parameters["pump1_stock_drug_concentration"]
        if target_concentration is None:
            target_concentration = self.drug_concentration
        main_pump_volume, drug_pump_volume = self.calculate_pump_volumes(target_concentration=target_concentration,
                                                                         dilution_factor=dilution_factor,
                                                                         current_volume=current_volume)
        lock_acquired_here = False
        self.updater.status_dict["dilution_pump_volumes"] = "current_concentration: %.2f, target_concentration: %.2f, main_pump_volume: %.2f, drug_pump_volume: %.2f" % (
            self.drug_concentration, target_concentration, main_pump_volume, drug_pump_volume)
        try:
            if not self.experiment.locks[self.vial].locked():
                self.experiment.locks[self.vial].acquire(blocking=True)
                lock_acquired_here = True
            postfill = self.parameters["postfill"] > 0
            make_device_dilution(device=self.experiment.device,
                                 vial=self.vial,
                                 pump1_volume=main_pump_volume,
                                 pump2_volume=drug_pump_volume,
                                 extra_vacuum=5,
                                 postfill=postfill)
            self.last_dilution_time = datetime.now()
            self.log_pump_data(main_pump_volume, drug_pump_volume)
            self.calculate_generation_concentration_after_dil(main_pump_volume=main_pump_volume,
                                                              drug_pump_volume=drug_pump_volume)
        finally:
            if lock_acquired_here:
                self.experiment.locks[self.vial].release()

    def calculate_pump_volumes(self, target_concentration, dilution_factor=None, current_volume=None):
        if dilution_factor is None:
            dilution_factor = self.parameters["dilution_factor"]
        if current_volume is None:
            current_volume = self.parameters["volume_vial"]

        total_vial_volume = 40 # ml
        current_volume = min(max(current_volume, 0.5), total_vial_volume)  # Ensure current volume is within bounds
        added_volume = current_volume * (dilution_factor - 1)  # Calculate the volume to be added
        added_volume = min(added_volume, total_vial_volume - current_volume)  # Ensure added volume is within bounds
        stock1_concentration = self.parameters["pump1_stock_drug_concentration"]
        stock2_concentration = self.parameters["pump2_stock_drug_concentration"]
        max_added_amount = added_volume * max(stock1_concentration, stock2_concentration)
        if self.drug_concentration is None:
            self.drug_concentration = self.parameters["pump1_stock_drug_concentration"]
        current_concentration = self.drug_concentration
        current_amount = current_concentration * current_volume
        total_volume = current_volume + added_volume
        added_amount = target_concentration * total_volume - current_amount
        added_amount = max(added_amount, 0)
        added_amount = min(added_amount, max_added_amount)
        added_concentration = added_amount / added_volume

        # pump1_volume * stock1_concentration + pump2_volume * stock2_concentration = added_volume * added_concentration
        # pump1_volume + pump2_volume = added_volume
        # solve for pump1_volume and pump2_volume, handling the case where stock1_concentration == stock2_concentration and stock1_concentration > stock2_concentration and stock1_concentration < stock2_concentration
        if stock1_concentration == stock2_concentration:
            main_pump_volume = added_volume / 2
            drug_pump_volume = added_volume / 2

        elif stock1_concentration > stock2_concentration:
            drug_pump_volume = added_volume * (stock1_concentration - added_concentration) / (stock1_concentration - stock2_concentration)
            main_pump_volume = added_volume - drug_pump_volume
        else:
            main_pump_volume = added_volume * (added_concentration - stock2_concentration) / (stock1_concentration - stock2_concentration)
            drug_pump_volume = added_volume - main_pump_volume

        main_pump_volume = min(max(main_pump_volume, 0), added_volume)
        drug_pump_volume = min(max(drug_pump_volume, 0), added_volume)
        self.updater.status_dict["pump_volume_calculations"] = "current_concentration: %.2f, target_concentration: %.2f, current_volume: %.2f, added_volume: %.2f, added_concentration: %.2f, main_pump_volume: %.2f, drug_pump_volume: %.2f" % (
            current_concentration, target_concentration, current_volume, added_volume, added_concentration, main_pump_volume, drug_pump_volume)

        return main_pump_volume, drug_pump_volume

    def calculate_generation_concentration_after_dil(self, main_pump_volume, drug_pump_volume):
        v0 = self.parameters["volume_vial"]
        total_volume = v0 + main_pump_volume + drug_pump_volume
        dilution_factor = total_volume / v0
        if self.generation is None:
            generation = np.log2(dilution_factor)
        else:
            generation = self.generation + np.log2(dilution_factor)
        try:
            stock1_concentration = self.parameters["pump1_stock_drug_concentration"]
        except KeyError:
            stock1_concentration = 0
        stock2_concentration = self.parameters["pump2_stock_drug_concentration"]

        # Calculate the new drug concentration after dilution and adding drug
        drug_concentration = (v0 * self.drug_concentration + main_pump_volume * stock1_concentration +
                              drug_pump_volume * stock2_concentration) / total_volume
        self.log_generation(generation, drug_concentration)  # also stores to self
        self.get_latest_data_from_db()  # TODO: speed up by not querying db again

    def get_culture_status_dict(self):
        culture_info = {
            "od": self.od,
            "growth_rate": self.growth_rate,
            "drug_concentration": self.drug_concentration,
            "generation": self.generation,
            "last_stress_increase_generation": self.last_stress_increase_generation,
            "last_dilution_time": self.last_dilution_time,
            "parameters": self.parameters.inner_dict,
            "updater_status": self.updater.status_dict,
        }
        return culture_info





--- flask_app/experiment/database_models.py ---
# models.py
from datetime import datetime

from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import JSON
db = SQLAlchemy()
from experiment.ModelBasedCulture.culture_growth_model import culture_growth_model_default_parameters
from experiment.ModelBasedCulture.morbidostat_updater import morbidostat_updater_default_parameters

name_parameters = {"name": "Species 1",
                   "description": "Strain 1"}

# merge but make name and description first in the dictionary
culture_parameters = {**name_parameters, **morbidostat_updater_default_parameters}

default_parameters = {"stock_volume_drug": 1000, "stock_volume_main": 2000,
                      "stock_volume_waste": 5000,
                      'cultures': {i: culture_parameters for i in range(1, 8)},
                      'growth_parameters': {i: culture_growth_model_default_parameters for i in range(1, 8)}}


class ExperimentModel(db.Model):
    __tablename__ = 'experiments'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False, unique=True)
    status = db.Column(db.String(64), nullable=False, default=lambda: "inactive")
    parameters = db.Column(JSON, nullable=False, default=lambda: default_parameters)

    def to_dict(self):
        parameters = self.parameters.copy()
        parameters['cultures'] = {int(key): value for key, value in parameters['cultures'].items()}
        return {
            'id': self.id,
            'name': self.name,
            'status': self.status,
            'parameters': self.parameters}


class PumpData(db.Model):
    __tablename__ = 'pump_data'

    id = db.Column(db.Integer, primary_key=True)

    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False, index=True)
    vial_number = db.Column(db.Integer, nullable=False, index=True)
    timestamp = db.Column(db.DateTime, default=datetime.now, index=True)

    volume_main = db.Column(db.Float, nullable=False)
    volume_drug = db.Column(db.Float, nullable=False)
    volume_waste = db.Column(db.Float, nullable=False)
    # To represent the relationship between an experiment and its pump data
    experiment = db.relationship('ExperimentModel', backref='pump_data')

    def to_dict(self):
        return {
            'id': self.id,
            'experiment_id': self.experiment_id,
            'vial_number': self.vial_number,
            'timestamp': self.timestamp.isoformat(),
            'volume_main': self.volume_main,
            'volume_drug': self.volume_drug,
            'volume_waste': self.volume_waste
        }


class CultureGenerationData(db.Model):
    __tablename__ = 'generation_data'

    id = db.Column(db.Integer, primary_key=True)

    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False, index=True)
    vial_number = db.Column(db.Integer, nullable=False, index=True)
    timestamp = db.Column(db.DateTime, default=datetime.now, index=True)

    generation = db.Column(db.Integer, nullable=False)
    drug_concentration = db.Column(db.Float, nullable=False)

    # To represent the relationship between an experiment and its cultures
    experiment = db.relationship('ExperimentModel', backref='generation_data')

    def to_dict(self):
        return {
            'id': self.id,
            'experiment_id': self.experiment_id,
            'vial_number': self.vial_number,
            'timestamp': self.timestamp.isoformat(),
            'generation': self.generation,
            'drug_concentration': self.drug_concentration
        }


class CultureData(db.Model):
    __tablename__ = 'culture_data'

    id = db.Column(db.Integer, primary_key=True)

    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False, index=True)
    vial_number = db.Column(db.Integer, nullable=False,index=True)
    timestamp = db.Column(db.DateTime, default=datetime.now, index=True)

    od = db.Column(db.Float, nullable=True)
    growth_rate = db.Column(db.Float, nullable=True)
    rpm = db.Column(db.Float, nullable=True)

    # To represent the relationship between an experiment and its cultures
    experiment = db.relationship('ExperimentModel', backref='culture_data')

    def to_dict(self):
        return {
            'id': self.id,
            'experiment_id': self.experiment_id,
            'vial_number': self.vial_number,
            'timestamp': self.timestamp.isoformat(),
            'od': self.od_reading,
            'growth_rate': self.growth_rate,
            'rpm': self.rpm
        }


--- flask_app/experiment/experiment.py ---
import traceback
import threading
import time
import queue

import sys
import io
from copy import deepcopy
from pprint import pformat, pprint

import numpy as np
import schedule
from experiment.database_models import ExperimentModel
from .ModelBasedCulture.culture_growth_model import culture_growth_model_default_parameters
from .ModelBasedCulture.morbidostat_updater import morbidostat_updater_default_parameters
from .culture import Culture
from flask import current_app


class ExperimentWorker:
    def __init__(self, experiment):
        self.experiment = experiment
        self.od_worker = QueueWorker(experiment=self.experiment, worker_name='OD_worker')
        self.dilution_worker = QueueWorker(experiment=self.experiment, worker_name='Dilution_worker')
        self.thread = threading.Thread(target=self.run_loop, daemon=False)
        self.thread.start()

    def run_loop(self):
        print('Experiment worker started')
        self.experiment.device.valves.close_all()
        self.experiment.device.eeprom.save_config_to_eeprom()
        while True:
            status = self.experiment.get_status()
            if status == 'stopped' or status == 'stopping':
                self.stop() # stop the experiment worker
                break
            else:
                self.experiment.schedule.run_pending()
                # print("ran pending", time.ctime())
            time.sleep(1)

    def stop(self):
        print("Stopping experiment worker: stopping dilution and OD workers")
        self.od_worker.stop()
        self.dilution_worker.stop()
        while self.dilution_worker.thread.is_alive() or self.od_worker.thread.is_alive():
            print("One of the workers is still alive")
            if self.dilution_worker.thread.is_alive():
                print("Waiting for dilution worker to stop")
            if self.od_worker.thread.is_alive():
                print("Waiting for OD worker to stop")
            time.sleep(0.5)
        print("OD and dilution workers stopped. Stopping stirrers")
        self.experiment.device.stirrers.set_speed_all("stopped")
        print("Experiment worker stopped")


class QueueWorker:
    def __init__(self, experiment, worker_name):
        self.name = worker_name
        self.experiment = experiment
        self.queue = queue.Queue(maxsize=1)
        self.thread = threading.Thread(target=self.process_queue, args=[self.queue], daemon=False)
        self.is_performing_operation = False
        self.paused = False
        self.thread.start()

    def stop(self):
        self.queue.put(None)

    def process_queue(self, q):
        while True:
            operation = q.get()
            if operation is None:  # None is a sentinel value indicating to stop
                break
            if self.paused:
                print("Worker %s paused" % self.name)
                while self.paused:
                    time.sleep(1)
                print("Worker %s resumed" % self.name)
            self.is_performing_operation = True
            try:
                with self.experiment.app.app_context():
                    try:
                        operation()
                    except Exception as e:
                        # print full traceback
                        traceback.print_exc()
                        print("Exception in worker %s: %s" % (self.name, e))
            finally:
                self.is_performing_operation = False


# class AutoCommitParameters:
#     def __init__(self, model, db):
#         self.model = model
#         self.db = db
#
#     def __getattr__(self, name):
#         return self.model.parameters[name]
#
#     def __setattr__(self, name, value):
#         if name in ["model", "db"]:
#             self.__dict__[name] = value
#         else:
#             self.model.parameters[name] = value
#             self.model.parameters = self.model.parameters
#             self.db.session.add(self.model)
#             self.db.session.commit()


class Experiment:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is not None:
            if cls._instance.status != "stopped":
                print("Experiment instance already exists and is not stopped. Stopping it now.")
                cls._instance.stop()
            else:
                print("Experiment instance already exists")
        cls._instance = super(Experiment, cls).__new__(cls)
        return cls._instance

    def __init__(self, device, experiment_model, db):
        self.app = current_app._get_current_object()
        self.db = db
        self.model = experiment_model  # Store the database model object
        self.device = device
        self._status = self.model.status
        self.schedule = schedule.Scheduler()
        self.locks = {i: threading.Lock() for i in range(1, 8)}
        self.experiment_worker = None
        self.cultures = {i: Culture(self, i, db) for i in range(1, 8)}
        self.db.session.commit()

    @property
    def parameters(self):
        return self.model.parameters

    @parameters.setter
    def parameters(self, new_parameters):
        with self.app.app_context():
            # Make a deep copy of the parameters, modify it, and assign it back
            id = self.model.id
            experiment_model = self.db.session.get(ExperimentModel, id)

            # modify to float
            for v, culture_parameters in new_parameters["cultures"].items():
                for key, value in new_parameters["cultures"][v].items():
                    if key in morbidostat_updater_default_parameters.keys():
                        if type(value) not in [int, float]:
                            value = float(value)
                            new_parameters["cultures"][v][key] = value
            if "growth_parameters" in new_parameters.keys():
                for v, culture_parameters in new_parameters["growth_parameters"].items():
                    for key, value in new_parameters["growth_parameters"][v].items():
                        if key in culture_growth_model_default_parameters.keys():
                            if type(value) not in [int, float]:
                                value = float(value)
                                new_parameters["growth_parameters"][v][key] = value
            # print("New parameters", new_parameters)
            experiment_model.parameters = new_parameters
            self.model.parameters = new_parameters
            self.db.session.commit()

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, value):
        self._status = value
        self.model.status = value
        self.db.session.commit()
        print(self.model.status,"status changed to", value)

    def _delete_all_data(self):
        for v in range(1, 8):
            self.cultures[v]._delete_all_records()

    def start(self):
        if self.experiment_worker is None or not self.experiment_worker.thread.is_alive():
            self.status = "starting"
            self.experiment_worker = ExperimentWorker(self)
            self.device.stirrers.set_speed_all("high")
            # self.device.eeprom.save_config_to_eeprom()
            self.make_schedule()
            self.status = "running"
        else:
            print("Experiment is already running.")
            if self.experiment_worker.dilution_worker.paused:
                print("Dilution worker is paused. Resuming.")
                self.experiment_worker.dilution_worker.paused = False

    def pause_dilution_worker(self):
        self.status = "paused"
        self.experiment_worker.dilution_worker.paused = True

    def stop(self):
        if self.status == "stopped":
            print("Experiment is already stopped.")
        self.status = "stopping"
        if self.experiment_worker is not None:
            if self.experiment_worker.dilution_worker.thread.is_alive() or self.experiment_worker.od_worker.thread.is_alive():
                print("Worker is finishing up. Waiting for it to finish.")
            while self.experiment_worker.dilution_worker.thread.is_alive() or self.experiment_worker.od_worker.thread.is_alive():
                time.sleep(0.5)
            print("dilution worker and od worker stopped")
        self.status = "stopped"
        return

    def measure_od_and_rpm_in_background(self):
        def task():
            available_vials = []
            try:
                for vial in range(1, 8):
                    if not self.locks[vial].locked():
                        self.locks[vial].acquire(blocking=False) # blocking=False means don't wait for lock, just check if it's available
                        available_vials.append(vial)
                new_rpms = self.device.stirrers.measure_all_rpms(vials_to_measure=available_vials)
                new_ods = self.measure_od_all(vials_to_measure=available_vials)
                for vial in available_vials:
                    self.cultures[vial].log_od_and_rpm(new_ods[vial],new_rpms[vial])
            finally:
                for vial in available_vials:
                    self.locks[vial].release()
        if self.experiment_worker.od_worker.queue.empty():
            self.experiment_worker.od_worker.queue.put(task)
            # print("Task to measure optical density in available vials queued for background execution.")
        else:
            print("Task to measure optical density already in queue. Skipping.")

    # def make_dilution_queued(self, vial_number, main_pump_volume, drug_pump_volume, extra_vacuum=5):
    #     print(f"Attempting to dilute vial {vial_number} in background.")
    #     if self.experiment_worker.dilution_worker.paused:
    #         print("Dilution worker paused. Dilution will not be attempted.")
    #         return
    #
    #     def task():
    #         lock_acquired_here = False
    #         try:
    #             self.locks[vial_number].acquire(blocking=True, timeout=15)
    #             lock_acquired_here = True
    #             self.cultures[vial_number].make_dilution(
    #                 pump1_volume=main_pump_volume,
    #                 pump2_volume=drug_pump_volume,
    #                 pump3_volume=0,  # pump3 not connected
    #                 extra_vacuum=extra_vacuum)
    #         finally:
    #             if lock_acquired_here:
    #                 self.locks[vial_number].release()
    #
    #     self.experiment_worker.dilution_worker.queue.put(task)
    #     print(f"Task to dilute vial {vial_number} queued for background execution.")

    def update_cultures_in_background(self):
        def task():
            for vial in range(1, 8):
                if not self.status == "running":
                    break
                self.cultures[vial].update()
        if self.experiment_worker.dilution_worker.queue.empty():
            self.experiment_worker.dilution_worker.queue.put(task)
            # print("Task to update cultures queued for background execution.")
        else:
            print("Task to update cultures already in queue. Skipping.")

    def measure_od_all(self, vials_to_measure=(1, 2, 3, 4, 5, 6, 7)):
        """
        Measure optical density of all vials in the device
        :param vials_to_measure: tuple of vials to measure
        :return: dictionary of measured optical density values
        """
        measured_od_values = {}
        if len(vials_to_measure) > 0:
            for vial in vials_to_measure:
                self.device.stirrers.set_speed(vial=vial, speed="low")
            time.sleep(4)

            for vial in vials_to_measure:
                od, signal = self.device.od_sensors[vial].measure_od()
                measured_od_values[vial] = od
            for vial in vials_to_measure:
                self.device.stirrers.set_speed(vial=vial, speed="high")
        return measured_od_values

    def reconnect_device_if_disconnected(self):
        if self.device.is_connected():
            return
        else:
            print("Device disconnected. Attempting to reconnect.")
            self.device.connect()

    def make_schedule(self):
        print("Making schedule")
        self.schedule.clear()
        self.schedule.every().minute.at(":05").do(self.update_cultures_in_background)
        self.schedule.every().minute.at(":00").do(self.measure_od_and_rpm_in_background)
        # self.schedule.every().minute.at(":20").do(self.reconnect_device_if_disconnected)
        # self.schedule.every().minute.at(":20").do(self.measure_od_in_background)
        # self.schedule.every().minute.at(":40").do(self.measure_od_in_background)

    def get_status(self):
        # Simulated method to get experiment status from database
        return self.status

    def get_experiment_status_dict(self):
        info={}
        for vial in range(1, 8):
            c = self.cultures[vial]
            info[vial] = c.get_culture_status_dict()
        return info


def object_to_dict(obj):
    if not hasattr(obj, "__dict__"):
        return repr(obj)
    result = {}

    for key, value in obj.__dict__.items():
        if isinstance(value, dict):
            # if the value is a dictionary, we represent it as a multi-line string
            value = '\n'.join([f'{k}: {v}' for k, v in value.items()])
        else:
            value = repr(value)  # Otherwise, we use repr to get a string representation of the attribute value

        result[key] = value

    return result


--- flask_app/experiment/export.py ---
import json
import os
import csv
from collections import defaultdict
from pprint import PrettyPrinter


def clean_experiment_name(experiment_name):
    forbidden_chars = ['\\', '/', ':', '*', '?', '"', '<', '>', '|']
    experiment_name = experiment_name.replace("/", "_")
    new_experiment_name = ''.join([char for char in experiment_name if char not in forbidden_chars])
    new_experiment_name = new_experiment_name.strip()
    if new_experiment_name != experiment_name:
        print(f"Experiment name {experiment_name} contains forbidden characters. Replacing with {new_experiment_name}")
        experiment_name = new_experiment_name
    return experiment_name


def export_culture_plot_html(culture, output_directory, predicted=False):
    experiment_name = culture.experiment.model.name
    vial = culture.vial
    if predicted:
        fig = culture.plot_predicted()
    else:
        fig = culture.plot()
    # clear experiment name from characters forbidden in file names such as !, ?, etc.
    experiment_name = clean_experiment_name(experiment_name)

    output_file = os.path.join(output_directory, experiment_name, 'vial_%d_plot.html' % int(vial))
    output_file = os.path.abspath(output_file)
    if not os.path.exists(os.path.dirname(output_file)):
        os.makedirs(os.path.dirname(output_file))
    fig.write_html(output_file)
    return output_file


def export_culture_csv(culture, output_directory):
    experiment_name = culture.experiment.model.name
    experiment_name = clean_experiment_name(experiment_name)

    vial = culture.vial
    ods, mus, rpms = culture.get_last_ods_and_rpms(limit=1000000)
    gens, concs = culture.get_last_generations(limit=1000000)

    # Combine all dictionaries into one
    combined = defaultdict(lambda: [None, None, None, None])  # Default value is a list of four None values

    for dt, value in ods.items():
        combined[dt][0] = value

    for dt, value in mus.items():
        combined[dt][1] = value

    for dt, value in gens.items():
        combined[dt][2] = value

    for dt, value in concs.items():
        combined[dt][3] = value

    # Create the output file path
    output_file = os.path.join(output_directory, experiment_name, 'vial_%d_data.csv' % int(vial))
    output_file = os.path.abspath(output_file)
    # Create the output directory if it doesn't exist
    if not os.path.exists(os.path.dirname(output_file)):
        os.makedirs(os.path.dirname(output_file))

    # Write data to the CSV file, sorted by datetime
    with open(output_file, 'w', newline='') as csvfile:
        fieldnames = ['Time', 'OD', 'mu', 'generation', 'concentration']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for dt in sorted(combined.keys()):
            writer.writerow({'Time': dt, 'OD': combined[dt][0], 'mu': combined[dt][1], 'generation': combined[dt][2],
                             'concentration': combined[dt][3]})
    print("Exported CSV file to %s" % output_file)
    return output_file


def export_parameters(experiment, output_directory):
    experiment_name = experiment.model.name
    experiment_name = clean_experiment_name(experiment_name)
    output_directory = os.path.join(output_directory, experiment_name)
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    output_file_txt = os.path.join(output_directory, "experiment_parameters.txt")
    output_file_json = os.path.join(output_directory, "experiment_parameters.json")

    with open(output_file_txt, "w+") as f:
        pp = PrettyPrinter(stream=f)
        pp.pprint(experiment.model.parameters)
    with open(output_file_json, "w+") as f:
        json.dump(experiment.model.parameters, f)

--- flask_app/experiment/growth_rate.py ---
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit

# from replifactory.util.other import read_csv_tail


def growth_function(t, N0, growth_rate):
    y = N0 * np.exp(growth_rate * t)
    return y


def calculate_growth_rate(time_values, od_values):
    """
    fits exponential growth curve and returns growth rate calculated over the entire time window.
    time window must not include dilution.
    time values must be in seconds.
    """
    assert (
        1 < time_values[-1] < 1e10
    ), "time must be time in seconds since 1970-01-01 00:00:00"

    if (
        len(time_values) < 6
    ):  # at least 6 data points required for reasonable measurement.
        return np.nan, np.nan, np.nan

    if (
        np.diff(time_values).max() > 30 * 60
    ):  # half an hour gap in the data, major problem.
        return np.nan, np.nan, np.nan

    # denoise, trim
    if len(time_values) >= 10:
        median_window = int(len(time_values) / 8) + 1
        od_values = (
            pd.Series(od_values).rolling(median_window * 2, center=True).median()
        )
        time_values = time_values[median_window : -(median_window - 1)]
        od_values = od_values[median_window : -(median_window - 1)]

    # convert to hrs
    hours = np.array(time_values) / 3600
    hours = hours - min(hours)

    try:
        popt, pcov = curve_fit(growth_function, hours, od_values, p0=(1e-3, 0.3))
    except Exception:
        return np.nan, np.nan, np.nan
    timepoint = (float(time_values[0]) + time_values[-1]) / 2
    growth_rate = popt[1]
    growth_rate_error = np.sqrt(np.diag(pcov))[1]
    return timepoint, growth_rate, growth_rate_error


# def get_last_gr(od_filepath):
#     """
#     returns the last growth rate in an od.csv file,
#     calculated over an appropriate time window
#     """
#     df = read_csv_tail(od_filepath, lines=300)
#     df = df[df.index >= df.index[-1] - 60 * 60 * 5]  # cut last 5 hours
#     t = df.index.values
#     od = df.values.ravel()
#     timepoint, growth_rate, error = calculate_last_growth_rate(t, od)
#     return timepoint, growth_rate, error


def calculate_last_growth_rate(t, od):
    """
    returns the most recent growth rate in an OD sequence,
    calculated over an appropriate time window (~t_doubling/2)
    """
    if len(od) == 0:
        return np.nan, np.nan, np.nan
    od[od <= 0] = 1e-6
    od_delta = abs(od.max() - od.min())
    min_window_size = 10
    if od_delta < 0.1:
        max_window_size = 300
    else:
        max_window_size = 60

    timepoint, growth_rate, error = np.nan, np.nan, np.nan
    # initial guess
    window_size = min(60, (t[-1] - t[0]) / 60)  # minutes
    guessed_td = np.nan
    tmax = t[-1]

    for _ in range(4):
        tmin = tmax - window_size * 60
        imin = np.where(t >= tmin)[0][0]
        tw = t[imin:]
        odw = od[imin:]
        timepoint, growth_rate, error = calculate_growth_rate(tw, odw)
        td = np.log(2) / growth_rate  # hours
        if not np.isfinite(td):
            break
        guess_error = abs((td - guessed_td) / td)
        guessed_td = td

        new_window_size = int(
            abs(td) * 60 * 0.5
        )  # optimum window size [minutes] is ~half the doubling time
        new_window_size = max(new_window_size, min_window_size)
        new_window_size = min(new_window_size, max_window_size)
        if guess_error < 0.05:
            break
        if t[0] > tmin:
            break
        if new_window_size == window_size:
            break
        else:
            window_size = new_window_size

    return timepoint, growth_rate, error


# def sliding_window_growth_rate(time_values, od_values, window_size_minutes):
#     """
#     time_values in seconds
#     window size in minutes
#     """
#     time_values = np.array(time_values)
#     od_values = np.array(od_values)
#     od_values[od_values <= 0] = 1e-6
#
#     growth_rates = []
#     errors = []
#     timepoints = []
#     for i in range(len(time_values)):
#         tmin = time_values[i]
#         tmax = tmin + window_size_minutes * 60
#         if tmax <= time_values[-1]:
#             imax = np.where(time_values >= tmax)[0][0]
#             time_window = time_values[i:imax + 1]
#             od_window = od_values[i:imax + 1]
#
#             timepoint = (tmin+tmax)/2
#             try:
#                 growth_rate, error = calculate_growth_rate(time_window, od_window)
#             except:
#                 growth_rate, error = np.nan, np.nan
#             timepoints += [timepoint]
#             growth_rates += [growth_rate]
#             errors += [error]
#     growth_rates = np.array(growth_rates)
#     errors = np.array(errors)
#     timepoints = np.array(timepoints)
#     return timepoints, growth_rates, errors
#
#
# def sliding_window_doubling_time(t, od, window_size_minutes=20):
#     timepoints, growth_rates, gr_errors = sliding_window_growth_rate(t, od, window_size_minutes=window_size_minutes)
#     t_doubling = np.log(2) / growth_rates
#     t_doubling_error = t_doubling * gr_errors / growth_rates
#     return timepoints, t_doubling, t_doubling_error

# for i in range(len(od)):
#     imax = i + 10
#     if len(od) <= imax:
#         tmax = t[imax]
#         imax = np.where(t >= tmax)[0][0]
#         tw = t[i:imax + 1]
#         odw = od[i:imax + 1]
#         timepoint, growth_rate, error = calculate_last_growth_rate(tw, odw)
#         timepoints += [timepoint]
#         growth_rates += [growth_rate]
#         errors += [error]


def adaptive_window_growth_rate(t, od, dilution_timepoints=None):
    timepoints, growth_rates, errors = [], [], []
    for i in range(len(od) - 10):
        jmin = i
        jmax = jmin + 10
        if t[jmax] - t[0] <= 3600 * 5:
            jmin = 0
        else:
            tmax = t[jmax]
            tmin = tmax - 3600 * 5
            if dilution_timepoints is not None:
                tdil = [t for t in dilution_timepoints if tmin < t < tmax]
                if len(tdil) > 0:
                    tmin = tdil[-1]
            jmin = np.where(t >= tmin)[0][0]

        tw = t[jmin:jmax]
        odw = od[jmin:jmax]

        timepoint, growth_rate, error = calculate_last_growth_rate(tw, odw)
        timepoints += [timepoint]
        growth_rates += [growth_rate]
        errors += [error]

    growth_rates = np.array(growth_rates)
    timepoints = np.array(timepoints)
    errors = np.array(errors)
    return timepoints, growth_rates, errors


def adaptive_window_doubling_time(t, od, dilution_timepoints):
    timepoints, growth_rates, gr_errors = adaptive_window_growth_rate(
        t, od, dilution_timepoints
    )
    t_doubling = np.log(2) / growth_rates
    t_doubling_error = t_doubling * gr_errors / growth_rates
    return timepoints, t_doubling, t_doubling_error


def plot_gr(time_values, od_values, dilution_timepoints=None):
    od = np.array(od_values)
    t = np.array(time_values)

    fig, ax = plt.subplots(figsize=[16, 8], dpi=100)
    # i = 0
    # lines = []
    ax.plot(t / 3600, od, "k.", label="Optical Density")
    # ax.set_ylim(-0.05, 1.6)
    od[od <= 0] = 1e-6
    ax.set_ylabel("Optical Density")
    ax.set_xlabel("Time [hours]")
    ax2 = ax.twinx()

    # if not adaptive_window:
    #     colors = ["xkcd:dark red", "xkcd:light orange", "xkcd:green", "xkcd:purple"]
    #     for c, ws in zip(colors[:len(window_sizes_minutes)], window_sizes_minutes):
    #         td_timepoints, td, tderr = sliding_window_doubling_time(t, od, window_size_minutes=ws)
    #
    #         markers, caps, bars = ax2.errorbar(td_timepoints / 3600, td, tderr, color=c,
    #                                            alpha=0.5, label="doubling time, %d min time windows" % ws)
    #         [bar.set_alpha(0.1) for bar in bars]

    td_timepoints, td, tderr = adaptive_window_doubling_time(
        t, od, dilution_timepoints=dilution_timepoints
    )

    markers, caps, bars = ax2.errorbar(
        td_timepoints / 3600, td, tderr, alpha=0.5, label="doubling time"
    )
    [bar.set_alpha(0.1) for bar in bars]
    try:
        td = np.array(td)
        tderr = np.array(tderr)
        tdmax = np.nanmax(td[tderr < 0.05])
        tdmin = np.nanmin(td[tderr < 0.05])
        ax2.set_ylim(tdmin * 0.5, tdmax * 1.2)
    except Exception:
        pass

    ax2.grid()
    ax2.set_ylabel("Doubling time [hours]")
    # labels = [line.get_label() for line in lines]
    # ax.legend(loc=1)
    # ax2.legend(loc=2)
    # plt.show()
    return fig


--- flask_app/experiment/plot.py ---
import json
from datetime import timedelta, datetime
import plotly.graph_objs as go

from experiment.ModelBasedCulture.culture_growth_model import CultureGrowthModel


def plot_culture(culture, limit=100000):
    culture_parameters = culture.updater.__dict__

    if isinstance(culture, CultureGrowthModel):
        ods = {p[1]: p[0] for p in culture.population}
        mus = {p[1]: p[0] for p in culture.effective_growth_rates}
        concs = {p[1]: p[0] for p in culture.doses}
        gens = {p[1]: p[0] for p in culture.generations}
        rpms = {}
    else:
        # Extract data from real experiment
        ods, mus, rpms = culture.get_last_ods_and_rpms(limit=limit)
        gens, concs = culture.get_last_generations(limit=limit)

    if len(ods) == 0:
        trace1 = go.Scattergl(
            x=[],
            y=[],
            mode='markers',
            marker=dict(
                color='black'
            ),
            name='Optical Density',
            yaxis='y1'  # Set to the first y-axis
        )
    else:
        trace1 = go.Scattergl(
            x=list(ods.keys()),
            y=list(ods.values()),
            mode='markers',
            marker=dict(
                color='black'
            ),
            name='Optical Density',
            yaxis='y1')

    trace2 = go.Scattergl(
        x=list(gens.keys()),
        y=list(gens.values()),
        mode='lines+markers',
        line=dict(
            color='red',
            shape='linear',
        ),
        name='Generation',
        yaxis='y2'  # Set to the second y-axis
    )

    trace3 = go.Scattergl(
        x=list(concs.keys()),
        y=list(concs.values()),
        mode='lines+markers',
        line=dict(
            color='green',
            shape='hv',
        ),
        name='Concentration',
        yaxis='y3'  # Set to the third y-axis
    )
    if len(mus) > 0:
        trace4 = go.Scattergl(
            x=list(mus.keys()),
            y=list(mus.values()),
            mode='markers',
            line=dict(
                color='blue',
                shape='linear',
            ),
            name='Growth Rate',
            yaxis='y4'  # Set to the fourth y-axis
        )
    else:
        trace4 = go.Scattergl(
            x=[],
            y=[],
            mode='markers',
            line=dict(
                color='blue',
                shape='linear',
            ),
            name='Growth Rate',
            yaxis='y4'  # Set to the fourth y-axis
        )
    if len(rpms) == 0:
        x_rpm = []
        y_rpm = []
    else:
        x_rpm = list(rpms.keys())
        y_rpm = list(rpms.values())
    trace5 = go.Scattergl(
        x=x_rpm,
        y=y_rpm,
        mode='markers',
        line=dict(
            color='orange',
            shape='linear',
        ),
        name='RPM',
        yaxis='y5'  # Set to the fifth y-axis
    )
    import pprint
    pp = pprint.PrettyPrinter(indent=4)
    pretty_parameters = pp.pformat(culture_parameters)
    pretty_parameters = pretty_parameters.replace('\n', '<br>')

    try:
        xp = list(ods.keys())[0]
        yp = list(ods.values())[0]+0.01
    except IndexError:
        xp = datetime.now()
        yp = 0.01

    params_trace = go.Scattergl(
        x=[xp],  # Place it at the earliest time point
        y=[yp],  # Place it at the minimum OD
        mode='markers',
        marker=dict(
            size=0,  # Set marker size to zero to make it invisible
        ),
        hovertext=[pretty_parameters],  # Show parameters on hover
        name='Parameters',
        yaxis='y1',  # Align it with the first y-axis
    )

    layout = go.Layout(
        # title="Culture: " + str(vial_number) + "<br>Experiment: "+experiment_name,
        # annotations=[
        #     dict(
        #         x=0,
        #         y=0,
        #         showarrow=False,
        #         text=pretty_parameters,
        #         xref="paper",
        #         yref="paper",
        #         align='center'
        #     )
        # ],
        xaxis=dict(
            title='Time',
        ),
        yaxis=dict(
            title='Optical Density',
            automargin=True
        ),
        yaxis2=dict(
            title='Generation',
            overlaying='y',
            side='right',
            automargin=True,
        ),
        yaxis3=dict(
            title='Concentration',
            overlaying='y',
            side='left',
            position=0.97,
            automargin=True,
        ),
        yaxis4=dict(
            title='Growth Rate',
            overlaying='y',
            side='right',
            position=0.03,
            automargin=True,
        ),
        yaxis5=dict(
            title='RPM',
            overlaying='y',
            side='left',
            position=0.06,
            automargin=True,
        ),
    )
    fig = go.Figure(data=[trace1, trace2, trace3, trace4, trace5, params_trace], layout=layout)
    return fig

--- flask_app/migrations/env.py ---
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


--- flask_app/migrations/versions/84622d1915e6_add_rpm_column_to_culturedata.py ---
"""Add rpm column to CultureData

Revision ID: 84622d1915e6
Revises: 
Create Date: 2024-05-24 02:06:38.660720

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '84622d1915e6'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('culture_data', schema=None) as batch_op:
        batch_op.add_column(sa.Column('rpm', sa.Float(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('culture_data', schema=None) as batch_op:
        batch_op.drop_column('rpm')

    # ### end Alembic commands ###


--- flask_app/minimal_device/__init__.py ---


--- flask_app/minimal_device/adc.py ---
import time

import pyftdi.i2c


class Photodiodes:
    def __init__(self, device):
        self.device = device
        self.adc_port = None
        self.multiplexer_port = None

        if self.device.is_connected():
            self.connect()

    def connect(self):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock to connect photodiodes at time %s" % time.ctime())
        try:  # estimated time to complete the operation: 0.5s
            self.adc_port = self.device.i2c.get_port(
                self.device.PORT_ADC
            )  # photodiodes ADC
            self.multiplexer_port = self.device.i2c.get_port(self.device.PORT_GPIO_MULTIPLEXER_ADC)
            self.multiplexer_port.write_to(6, [0x00])  # set all GPIO pins as output
            self.multiplexer_port.write_to(7, [0x00])  # set all GPIO pins as output
        except pyftdi.i2c.I2cNackError:
            print("Photodiode multiplexer or ADC connection ERROR.")
        finally:
            self.device.lock_ftdi.release()

    def switch_to_vial(self, vial):
        vial = vial - 1
        assert 0 <= vial <= 6
        self.multiplexer_port.write_to(3, [6 - vial])

    def measure(self, gain=8, bitrate=16, continuous_conversion=False):
        ready_bit = 0b10000000
        if continuous_conversion:
            conversion_mode = 0b00010000
        else:
            conversion_mode = 0b00000000  # One-shot conversion mode
        bitrate_bits = {12: 0b0000, 14: 0b0100, 16: 0b1000, 18: 0b1100}
        bitrate_to_samples_per_second = {
            12: 240,  # from MCP3421 datasheet
            14: 60,
            16: 15,
            18: 3.75,
        }
        gain_bits = {1: 0b00, 2: 0b01, 4: 0b10, 8: 0b11}

        write_byte = (
            ready_bit | conversion_mode | bitrate_bits[bitrate] | gain_bits[gain]
        )
        self.adc_port.write([write_byte])

        new_data_is_ready = False
        for _ in range(100):  # try reading until conversion ready
            samples_per_second = bitrate_to_samples_per_second[bitrate]
            seconds_per_sample = 1 / samples_per_second

            time.sleep(seconds_per_sample)
            response = self.adc_port.read(4)
            data = response[:2]
            config = response[3:]
            if bitrate == 18:
                data = response[:3]  # 3 bytes for 18bit

            new_data_is_ready = (
                config[0] < 128
            )  # if bit 7 (ready bit) is 1: NOT READY YET!
            if new_data_is_ready:
                break

        assert new_data_is_ready
        data_bits = "".join([bin(x)[2:].rjust(8, "0") for x in data])[-bitrate:]
        sign_bit = data_bits[0]
        digital_signal = sum(
            [2**i for i in range(len(data_bits)) if data_bits[::-1][i] == "1"]
        )
        if sign_bit == "1":
            digital_signal = digital_signal - 2**bitrate
        millivolts = 2 * 2.048 / 2**bitrate * digital_signal * 1000 / gain
        millivolts = round(millivolts, 10)
        lsb_mv = (
            2.048 * 2 / 2**bitrate * 1000 / gain
        )  # least significant bit millivolts
        return millivolts, lsb_mv


--- flask_app/minimal_device/base_device.py ---
import os
import threading
import time
import traceback

import pyftdi.i2c
import usb

import yaml
from pyftdi.spi import SpiController
from pyftdi.usbtools import UsbTools

from .adc import Photodiodes
from .eeprom import EEPROM
from .lasers import Lasers
from .led import RGBLedController
from .od_sensor import OdSensor
from .pump import Pump
from .pwm import PwmController
from .stirrers import Stirrers
from .test_hardware import Testing
from .thermometers import Thermometers
from .valves import Valves
from .workers import QueueWorker
from .loading import load_config, load_object, save_object
from .other import CultureDict
from .device_data import default_device_data


class BaseDevice:
    PORT_ADC = 0x68  # MCP3421A0  1101 000
    # PORT_ADC = 0x69  # MCP3421A1  1101 001
    # PORT_ADC = 0x6a  # MCP3421A2  1101 010
    # PORT_ADC = 0x6b  # MCP3421A3  1101 011
    PORT_GPIO_MULTIPLEXER_LASERS = 0x20  # PCA 9555
    PORT_GPIO_MULTIPLEXER_ADC = 0x21  # PCA 9555
    PORT_GPIO_MULTIPLEXER_STIRRERS = 0x25  # PCA 9555
    PORT_THERMOMETER_VIALS = 0x49  # ADT 75  #0x4C?
    PORT_THERMOMETER_VIALS_v4 = 0x4C  # device version 4
    PORT_THERMOMETER_BOARD = 0x48  # ADT 75
    PORT_PWM = 0x5A  # PCA9685 motors
    PORT_RGB_PWM1 = 0x5C # PCA9685 LEDs 1-5
    PORT_RGB_PWM2 = 0x5D # PCA9685 LEDs 6-7
    PORT_EEPROM = 0x53  # deprecated

    def __init__(self, ftdi_address="ftdi://ftdi:2232h", connect=False, directory=None):
        t0 = time.time()
        print("Initializing device", time.ctime())
        self.ftdi_address = ftdi_address
        self.directory = directory

        self.active_pumps = (1, 2, 4)

        self.dilution_worker = None
        self.od_worker = None

        self.hard_stop_trigger = False
        self.soft_stop_trigger = False

        self.i2c = None
        self.spi = None
        self.device_data = default_device_data

        self.drying_prevention_pump_period_hrs = 12
        self.drying_prevention_pump_volume = 0.1
        self.setup_time = time.time()

        self.locks_vials = {v: threading.Lock() for v in range(1, 8)}
        self.lock_pumps = threading.Lock()
        # self.lock_spi = threading.Lock()
        # self.lock_i2c = threading.Lock()

        self.lock_ftdi = threading.Lock()

        self.file_lock = threading.Lock()
        # self.pump_calibrations_rotations_to_ml = {1: {}, 2: {}, 3: {}, 4: {}}
        self.pump_stock_concentrations = {1: None, 2: None, 3: None, 4: None}
        self.pump_stock_volumes = {1: None, 2: None, 3: None, 4: None}

        self.od_values = {v: None for v in range(1, 8)}
        self.pwm_controller = PwmController(device=self, frequency=50)
        self.valves = Valves(device=self)
        self.stirrers = Stirrers(device=self)
        self.photodiodes = Photodiodes(device=self)
        self.lasers = Lasers(device=self)
        self.rgb_leds = RGBLedController(device=self)
        self.od_sensors = {v: OdSensor(device=self, vial_number=v) for v in range(1, 8)}
        self.pump1 = Pump(device=self, cs=0)
        self.pump2 = Pump(device=self, cs=1)
        self.pump3 = Pump(device=self, cs=2)
        self.pump4 = Pump(device=self, cs=3)
        self.thermometers = Thermometers(device=self)
        self.eeprom = EEPROM(device=self)
        self.cultures = CultureDict(self)
        self.cultures[1] = None
        self.cultures[2] = None
        self.cultures[3] = None
        self.cultures[4] = None
        self.cultures[5] = None
        self.cultures[6] = None
        self.cultures[7] = None
        if self.directory is not None:
            try:
                self.load_dev_and_cultures_config()
                print("loaded", time.time() - t0)
            except FileNotFoundError:
                print("saving", time.time() - t0)
                self.save()
        if connect:
            self.connect()
        self.testing = Testing(self)

    def connect_i2c_spi(self, ftdi_address="ftdi://ftdi:2232h", retries=5):
        # acquire lock_pumps to prevent concurrent attempts to connect
        assert self.lock_pumps.acquire(timeout=5)
        try:
            self.spi = SpiController(cs_count=5)
            self.i2c = pyftdi.i2c.I2cController()
            for attempt in range(retries):
                try:
                    self.spi.configure(ftdi_address + "/1")
                    self.i2c.configure(ftdi_address + "/2", frequency=5e4)
                    print("closing SPI and I2C")
                    self.spi.close()
                    self.i2c.close()
                    print("opening SPI and I2C again")
                    self.spi.configure(ftdi_address + "/1")
                    self.i2c.configure(ftdi_address + "/2", frequency=5e4)
                    return
                except Exception as e:
                    # self.reset_usb_device()
                    self.disconnect_all()
                    print(f"Attempt {attempt + 1} failed: {e}")
                    time.sleep(0.5)
        finally:
            self.lock_pumps.release()
        raise ConnectionError("Failed to connect to I2C and SPI")

    def connect(self):
        self.connect_i2c_spi()
        self.pwm_controller.connect()  # valves and stirrers
        self.stirrers.connect()
        self.photodiodes.connect()
        self.lasers.connect()
        self.rgb_leds.connect()
        self.thermometers.connect()
        self.pump1.connect()
        self.pump2.connect()
        self.pump3.connect()
        self.pump4.connect()
        self.eeprom.connect()
        self.dilution_worker = QueueWorker(device=self, worker_name="dilution")
        self.od_worker = QueueWorker(device=self, worker_name="od")
        self.hard_stop_trigger = False
        self.soft_stop_trigger = False
        self.release_vial_locks()

    # def connect(self, ftdi_address="ftdi://ftdi:2232h", retries=10):
    #     # if ftdi_address is None:
    #     #     ftdi_address = self.ftdi_address
    #     # else:
    #     try:
    #         # t0=time.time()
    #         assert ftdi_address[-1] != "/", "ftdi_address should not end with a '/'"
    #         self.spi = SpiController(cs_count=5)
    #         self.spi.configure(ftdi_address + "/1")
    #         self.i2c = pyftdi.i2c.I2cController()
    #         self.i2c.configure(ftdi_address + "/2", frequency=5e4)
    #         self.pwm_controller.connect()  # valves and stirrers
    #         # self.valves.connect()
    #         self.stirrers.connect()
    #         self.photodiodes.connect()
    #         self.lasers.connect()
    #         self.thermometers.connect()
    #         self.pump1.connect()
    #         self.pump2.connect()
    #         self.pump3.connect()
    #         self.pump4.connect()
    #         self.eeprom.connect()
    #         # print("Device %s connection established" % ftdi_address)
    #         self.dilution_worker = QueueWorker(device=self, worker_name="dilution")
    #         self.od_worker = QueueWorker(device=self, worker_name="od")
    #         self.hard_stop_trigger = False
    #         self.soft_stop_trigger = False
    #
    #     # except USBError as ex:
    #     #     raise FtdiError('UsbError: %s' % str(ex)) from None
    #
    #     except pyftdi.ftdi.FtdiError as ex:
    #         raise ConnectionError("Connection failed! %s" % ex) from None
    #     except pyftdi.usbtools.USBError:
    #         if retries >0:
    #             try:
    #                 self.spi.terminate()
    #             except Exception:
    #                 pass
    #             try:
    #                 self.i2c.terminate()
    #             except Exception:
    #                 pass
    #             UsbTools.release_all_devices()
    #             UsbTools.flush_cache()
    #             print("Retrying connection...")
    #             self.connect(ftdi_address=ftdi_address, retries=retries - 1)
    #         print("Device connected but does not recognize the command.\nPlease reset connections.")
    #     except pyftdi.usbtools.UsbToolsError as ex:
    #         print("Connection failed! %s" % ex)
    #         print("Device %s not connected." % ftdi_address)
    #     for lock in self.locks_vials.values():
    #         if lock.locked():
    #             lock.release()

    @staticmethod
    def reset_usb_device():
        # Find the USB device
        dev = usb.core.find(idVendor=0x0403, idProduct=0x6010)  # FT2232H

        if dev is None:
            raise ValueError("Device not found")

        # Detach any kernel drivers and reset the device
        try:
            if dev.is_kernel_driver_active(0):
                dev.detach_kernel_driver(0)
            dev.reset()
            time.sleep(5)  # Wait for the device to reset and reinitialize
        except usb.core.USBError as e:
            print(f"Failed to reset the USB device: {e}")
            raise

    def reinitialize_workers(self):
        """
        Reinitialize the workers after directory change
        :return:
        """
        if self.dilution_worker is not None:
            self.dilution_worker.stop()
        if self.od_worker is not None:
            self.od_worker.stop()
        assert os.path.exists(self.directory)
        self.dilution_worker = QueueWorker(device=self, worker_name="dilution")
        self.od_worker = QueueWorker(device=self, worker_name="od")

    def disconnect_all(self):
        try:
            self.spi.terminate()
        except Exception:
            pass
        try:
            self.i2c.terminate()
        except Exception:
            pass

        UsbTools.release_all_devices()
        UsbTools.flush_cache()
        self.reset_usb_device()

    def hello(self):
        self.pwm_controller.play_turn_on_sound()
        self.lasers.blink()
        self.rgb_leds.blink_hello()
        print("Said hello from device")

    def update_cultures(self):
        def queued_function():
            for v, c in self.cultures.items():
                if self.soft_stop_trigger:
                    break
                if c is not None:
                    c.update()

        if self.dilution_worker.queue.empty():
            self.dilution_worker.queue.put(queued_function)
        else:
            print("Culture update not queued. dilution thread queue is not empty.")

    @property
    def pumps(self):
        return {1: self.pump1, 2: self.pump2, 3: self.pump3, 4: self.pump4}

    def stop_pumps(self):
        self.pump1.stop()
        self.pump2.stop()
        self.pump3.stop()
        self.pump4.stop()

    def measure_temperature(self):
        def queued_function():
            self.thermometers.measure_temperature()

        if self.od_worker.queue.empty():
            self.od_worker.queue.put(queued_function)
        else:
            print("Temperature measurement not queued. od thread queue is not empty.")

    def release_vial_locks(self):
        for lock in self.locks_vials.values():
            if lock.locked():
                lock.release()

    def release_locks(self):
        if self.is_pumping():
            self.stop_pumps()
            print("Stopped pumps")
        self.release_vial_locks()
        if self.lock_pumps.locked():
            self.lock_pumps.release()
            print("released pump lock")

    def is_pumping(self):
        return any(
            p.is_pumping() for p in [self.pump1, self.pump2, self.pump3, self.pump4]
        )

    def emergency_stop(self):
        # self.hard_stop_trigger = True
        self.pump1.stop()
        self.pump2.stop()
        self.pump3.stop()
        self.pump4.stop()
        self.stirrers.emergency_stop()

    def is_connected(self):
        try:
            if hasattr(self.spi, "_ftdi") and hasattr(self.i2c, "_ftdi"):
                return self.spi._ftdi.is_connected and self.i2c._ftdi.is_connected
            else:
                return False
        except:
            traceback.print_exc()
            return False

    def save(self):
        """
        saves calibration data and stock concentrations to self.directory/device_config.yaml
        """
        config_path = os.path.join(self.directory, "device_config.yaml")
        save_object(self, filepath=config_path)

    def load_dev_config(self):
        """
        loads calibration data and stock concentrations from self.directory/device_config.yaml
        """
        assert self.file_lock.acquire(timeout=5)
        try:
            config_path = os.path.join(self.directory, "device_config.yaml")
            if os.path.exists(config_path):
                load_config(self, filepath=config_path)
            else:
                print("No device config file found. Using default device config.")
        finally:
            self.file_lock.release()

    def load_cultures(self):
        """
        loads culture data from self.directory/cultures.yaml
        """
        assert self.file_lock.acquire(timeout=5)
        try:
            for v in range(1, 8):
                vial_directory = os.path.join(self.directory, "vial_%d" % v)
                vial_config_path = os.path.join(vial_directory, "culture_config.yaml")
                if os.path.exists(vial_config_path):
                    self.cultures[v] = load_object(vial_config_path)
                else:
                    print("No culture config file found for vial %d" % v)
        finally:
            self.file_lock.release()

    def load_dev_and_cultures_config(self):
        self.load_dev_config()
        self.load_cultures()

    def copy_all_culture_configs(self, source_exp_directory):
        for v in range(1, 8):
            source_config_path = os.path.join(
                source_exp_directory, "vial_%d/culture_config.yaml" % v
            )
            self.copy_culture_config(
                source_config_path=source_config_path, target_vial_number=v
            )

    def copy_culture_config(self, source_config_path, target_vial_number):
        source_culture = load_object(source_config_path)
        _class = source_culture.__dict__["_class"]
        target_culture = self.cultures[target_vial_number] = _class(
            self.directory, target_vial_number
        )

        for k in target_culture.__dict__.keys():
            if not k.startswith("_") and k not in [
                "vial_number",
                "directory",
                "file_lock",
                "od_blank",
            ]:
                target_culture.__dict__[k] = source_culture.__dict__[k]
        target_culture.save()

    def calibrate(self, dummy_data=False):
        if dummy_data:
            # self.calibration_mv_to_od = {1: {1: 5, 10: 2, 22: 0.5, 35: 0.1, 41: 0.0001},
            #                              2: {1: 5, 10: 2, 22: 0.5, 35: 0.1, 41: 0.0001},
            #                              3: {1: 5, 10: 2, 35: 0.1, 41: 0.0001},
            #                              4: {1: 5, 10: 2, 35: 0.1, 41: 0.0001},
            #                              5: {1: 5, 10: 2, 35: 0.1, 41: 0.0001},
            #                              6: {1: 5, 10: 2, 35: 0.1, 41: 0.0001},
            #                              7: {1: 5, 10: 2, 35: 0.1, 41: 0.0001}}
            for v in range(1, 8):
                self.calibration_od_to_mv[v] = {
                    11.973: [0.40625, 0.4103125],
                    5.644: [0.75, 0.7575],
                    2.661: [1.6484375, 1.664921875],
                    1.254: [4.2890625, 4.331953125],
                    0.591: [10.6796875, 10.786484375],
                    0.279: [21.1015625, 21.312578125],
                    0.131: [29.8671875, 30.165859375],
                    0.062: [38.1328125, 38.514140625],
                    0.029: [42.515625, 42.94078125],
                    0.014: [45.71875, 46.1759375],
                    0: [47.859375, 48.33796875],
                }

            self.calibration_fan_speed_to_duty_cycle = {
                1: {1: 0.3, 2: 0.6, 3: 1},
                2: {1: 0.3, 2: 0.6, 3: 1},
                3: {1: 0.3, 2: 0.6, 3: 1},
                4: {1: 0.3, 2: 0.6, 3: 1},
                5: {1: 0.3, 2: 0.6, 3: 1},
                6: {1: 0.3, 2: 0.6, 3: 1},
                7: {1: 0.3, 2: 0.6, 3: 1},
            }
            self.calibration_pump_rotations_to_ml = {
                1: {1: 0.184, 3: 0.55, 20: 3.59, 80: 14.23},
                2: {1: 0.184, 3: 0.55, 20: 3.59, 80: 14.23},
                3: {},
                4: {1: 0.17, 5: 0.64, 10: 1.05, 50: 5.1, 100: 7.55, 200: 13.71},
            }
            self.save()
            self.fit_calibration_functions()

    def show_parameters(self):
        self.stirrers.show_parameters()
        print()
        self.pump1.show_parameters()
        self.pump2.show_parameters()
        self.pump3.show_parameters()
        self.pump4.show_parameters()
        print()
        for od_sensor in self.od_sensors.values():
            od_sensor.plot_calibration_curve()

    def load_calibration(self, config_path):
        assert config_path.endswith("device_config.yaml")
        config = open(config_path).read()
        loaded_dict = yaml.load(config, Loader=yaml.Loader)
        # assert loaded_dict["_class"] == self.__class__
        for k in loaded_dict.keys():
            if k != "directory":
                self.__dict__[k] = loaded_dict[k]
        print("Loaded calibration data from %s" % config_path)
        self.fit_calibration_functions()


--- flask_app/minimal_device/device_data.py ---

default_device_data = {
    'calibrationModeEnabled': False,
    'valves': {
        'states': {
            1: 'open',
            2: 'open',
            3: 'open',
            4: 'open',
            5: 'open',
            6: 'open',
            7: 'open'
        }
    },
    'pumps': {
        'states': {
            1: 'stopped',
            2: 'stopped',
            3: 'stopped'
        },
        'calibration': {
            1: {1: 0.2, 5: 0.19, 10: 0.18, 50: 0.17},
            2: {1: 0.2, 5: 0.19, 10: 0.18, 50: 0.17},
            3: {1: 0.2, 5: 0.19, 10: 0.18, 50: 0.17},
            4: {1: 0.2, 5: 0.19, 10: 0.18, 50: 0.17}
        }
    },
    'stirrers': {
        'states': {
            1: 'stopped',
            2: 'stopped',
            3: 'stopped',
            4: 'stopped',
            5: 'stopped',
            6: 'stopped',
            7: 'stopped'
        },
        'calibration': {
            1: {'low': 0.1, 'high': 0.90},
            2: {'low': 0.1, 'high': 0.91},
            3: {'low': 0.1, 'high': 0.92},
            4: {'low': 0.1, 'high': 0.93},
            5: {'low': 0.1, 'high': 0.94},
            6: {'low': 0.1, 'high': 0.95},
            7: {'low': 0.1, 'high': 0.99}
        }
    },
    'ods': {
      'states': {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0},
        'odsignals': {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0},
        'calibration': {
        1: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            1.234: 3.719,
            4.567: 1.648},
        2: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            1.234: 3.719,
            4.567: 1.648},
        3: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            1.234: 3.719,
            4.567: 1.648},
        4: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            4.567: 1.648},
        5: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            4.567: 1.648},
        6: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            1.234: 3.719,
            4.567: 1.648},
        7: {0.00123: 40.123,
            0.234: 26.750,
            0.567: 8.367,
            1.234: 3.719,
            4.567: 1.648},
          },
        'calibration_coefs': {1: [4, 1, 10, -0.5, 4],
                              2: [4, 1, 10, -0.5, 4],
                              3: [4, 1, 10, -0.5, 4],
                              4: [4, 1, 10, -0.5, 4],
                              5: [4, 1, 10, -0.5, 4],
                              6: [4, 1, 10, -0.5, 4],
                              7: [4, 1, 10, -0.5, 4]},
    },
    'thermometers': {
        'states': {1:0, 2:0}}
}


--- flask_app/minimal_device/dilution.py ---
import os
import time


def close_valve_gracefully(device, vial):
    try:
        if device.is_pumping():
            device.pump4.stop()
            device.pump1.stop()
            device.pump2.stop()
            print("WARNING! Pumps stopped after diluting via vial %d at time %s" % (vial, time.ctime()))
            time.sleep(2)
    except Exception as e:
        print("Error stopping pumps: %s" % e)
    try:
        device.valves.close(valve=vial)
    except Exception as e:
        print("Error closing valve %d: %s" % (vial, e))


def make_device_dilution(device, vial, pump1_volume=0, pump2_volume=0, pump3_volume=0, extra_vacuum=5, postfill=True):
    assert 0 <= pump1_volume <= 30
    assert 0 <= pump2_volume <= 30
    assert 0 <= pump1_volume + pump2_volume <= 30
    assert 0 <= pump3_volume <= 30
    assert 0 <= extra_vacuum <= 20
    dilution_volume = pump1_volume + pump2_volume + pump3_volume
    waste_volume = dilution_volume + extra_vacuum

    vial_lock_acquired = device.locks_vials[vial].acquire(timeout=10)
    if not vial_lock_acquired:
        raise Exception("Could not acquire lock for vial %d at time %s" % (vial, time.ctime()))

    lock_pumps_acquired = device.lock_pumps.acquire(timeout=10)
    if not lock_pumps_acquired:
        device.locks_vials[vial].release()
        raise Exception("Could not acquire lock for pumps at time %s" % time.ctime())

    def pump_waste():
        device.stirrers.set_speed(vial=vial, speed="low")
        device.pump4.pump(waste_volume)
        vacuum_time_0 = time.time()
        stirrer_stopped = False
        while device.pump4.is_pumping():
            time.sleep(1)
            if time.time() - vacuum_time_0 > 3 and not stirrer_stopped:
                device.stirrers.set_speed(vial=vial, speed="stopped")
                stirrer_stopped = True
        device.stirrers.set_speed(vial=vial, speed="high")

    try:
        assert not device.is_pumping(), "pumping in progress"
        device.stirrers.set_speed(vial=vial, speed="high")
        time.sleep(0.2)
        device.valves.open(vial)

        if postfill:
            pump_waste()

        # add media to vial
        if pump1_volume > 0:
            device.pump1.pump(pump1_volume)
        if pump2_volume > 0:
            device.pump2.pump(pump2_volume)
        if pump3_volume > 0:
            device.pump3.pump(pump3_volume)

        while device.is_pumping():
            time.sleep(1)
            assert not device.hard_stop_trigger

        # pump waste
        if not postfill:
            pump_waste()
        time.sleep(2)
    finally:
        close_valve_gracefully(device, vial)
        device.locks_vials[vial].release()
        device.lock_pumps.release()
    return 0

--- flask_app/minimal_device/eeprom.py ---
import os
import time
import threading
import traceback
from queue import Queue

import numpy as np
import yaml
import gzip
from minimal_device.device_data import default_device_data

def make_addr_bytes(page=511, byte=63):
    two_bytes = page << 6 | byte
    byte1 = two_bytes >> 8
    byte2 = two_bytes & 0b11111111
    return byte1, byte2


class EEPROM:
    PAGE_TEST = 511

    class EepromWriter:
        def __init__(self, eeprom):
            print("Starting EEPROM writer worker thread", time.ctime())
            self.eeprom = eeprom
            self.data = None
            self.queue = Queue()
            self.timer = None
            self.lock = threading.Lock()
            self.worker_thread = threading.Thread(target=self.worker)
            self.worker_thread.start()

        def worker(self):
            while True:
                with self.lock:
                    data = self.data
                    self.data = None
                    if data is not None:
                        self.eeprom._write_to_eeprom(data)
                time.sleep(1)

        def add_data(self, data):
            with self.lock:
                self.data = data
                # print("Added data to EEPROM writer queue", time.ctime())

    def __init__(self, device):
        print("Initializing EEPROM", time.ctime())
        self.device = device
        self.port = None
        self.writer = self.EepromWriter(self)
        if self.device.is_connected():
            self.connect()
        self.using_filewriter = True
        self.filename = "db/device_data.yaml"
        if not os.path.exists("db"):
            self.filename = "../db/device_data.yaml"
        if not os.path.exists(self.filename):
            with open(self.filename, 'w') as file:
                yaml.dump(default_device_data, file)
            print(f"Created {self.filename} with default device data.")

############ Replace EEPROM with filewriter ############
    def log_config_from_file(self):
        filename = self.filename
        if not os.path.exists(filename):
            with open(filename, 'w') as file:
                yaml.dump(default_device_data, file)
            print(f"Created {filename} with default device data.")
        else:
            with open(filename, 'r') as file:
                self.device.device_data = yaml.load(file, Loader=yaml.Loader)
            print(f"Loaded device data from {filename}.")
        self.using_filewriter = True

    def _write_to_file(self, data):
        filename = self.filename
        with open(filename, 'w') as file:
            yaml.dump(data, file)
        print(f"Wrote data to {filename}.")

    def _read_from_file(self):
        filename = self.filename
        with open(filename, 'r') as file:
            data = yaml.load(file, Loader=yaml.Loader)
        print(f"Read data from {filename}.")
        return data

    def connect(self):
        """
        Connects to the EEPROM
        :return:
        """
        self.connect_without_load()
        try:
            self.load_config_from_eeprom()
        except Exception:
            print("Could not load config from EEPROM")
            traceback.print_exc()

    def connect_without_load(self):
        """
        Connects to the EEPROM without loading the config
        :return:
        """
        try:
            self.port = self.device.i2c.get_port(0x53)
        except Exception:
            traceback.print_exc()
            raise Exception("Could not connect to EEPROM")

    def save_config_to_eeprom(self):
        """
        Writes the device object config to the EEPROM
        :param from_file: file directory, the config is read from the file instead of the device object
        :return:
        """
        self.writer.add_data(self.device.device_data)

    def _write_to_eeprom(self, data):
        if self.using_filewriter:
            self._write_to_file(data)
            return

        config_to_write = data
        config_to_write = yaml.dump(config_to_write)
        config_to_write = config_to_write.encode("utf-8")
        config_to_write = gzip.compress(config_to_write)
        config_bytes = bytearray(config_to_write)
        # filler_size = 32768 - len(config_bytes)
        filler_size = 64
        # print("Writing", len(config_bytes), "bytes to EEPROM", time.ctime())
        # print(filler_size, "bytes of filler to write to EEPROM")
        for i in range(filler_size):
            config_bytes.append(0xFF)
        n_pages_to_write = int(np.ceil(len(config_bytes) / 64))


        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire ftdi lock for writing to EEPROM at time %s" % time.ctime())
        try:
            # print(n_pages_to_write,"pages to write to EEPROM")
            for page in range(n_pages_to_write):
                b1, b2 = make_addr_bytes(page=page, byte=0)
                self.port.write([b1, b2] + [b for b in config_bytes[64 * page : 64 * (page + 1)]])
            self.eeprom_config = self.device.device_data
        finally:
            self.device.lock_ftdi.release()
        #     if page % 20 == 0:
        #         print(
        #             "Writing to EEPROM: %d%% done" % (page / 5.12),
        #             end="                              \r",
        #         )
        # print("Writing new config to EEPROM COMPLETE")

    def load_config_from_eeprom(self):
        """
        Loads the config from the EEPROM into the device object
        :return:
        """
        loaded_config = self.read_eeprom()
        for k in default_device_data.keys():
            if k not in loaded_config.keys():
                raise Exception("Key not found in EEPROM")
        self.device.device_data = loaded_config
        if self.using_filewriter:
            print("Loaded config from file matching default config keys")
        else:
            self._write_to_file(loaded_config)
            print("Loaded config from EEPROM matching default config keys")

    def reset_memory(self):
        print("erasing memory and writing default config")
        self.device.lasers.switch_all_on()
        time.sleep(0.3)
        self.device.lasers.switch_all_off()
        time.sleep(0.3)
        self.device.lasers.switch_all_on()
        time.sleep(1)
        self.device.lasers.switch_all_off()

        self.erase_memory()
        self.device.device_data = default_device_data
        self.save_config_to_eeprom()
        for v in range(1, 8):
            self.device.valves.open(v)
        return

    def write_to_page(self, page, content, byte=0, fill=True):
        assert byte < 64
        content = yaml.dump(content)
        content_bytes = bytearray(content, "utf-8")
        assert len(content_bytes) <= 64
        if fill:
            filler_size = 64 - len(content_bytes)
            for i in range(filler_size):
                content_bytes.append(0xFF)
        b1, b2 = make_addr_bytes(page=page, byte=byte)
        self.port.write([b1, b2] + [b for b in content_bytes])

    def write_byte(self, page, byte, content_bytes):
        b1, b2 = make_addr_bytes(page=page, byte=byte)
        self.port.write([b1, b2] + [b for b in content_bytes])

    def read_from_page(self, page):
        tail = bytearray([0xFF] * 1)
        b1, b2 = make_addr_bytes(page=page, byte=0)
        self.port.write([b1, b2], relax=False)
        bytes_read = self.port.read(64)
        assert len(bytes_read.partition(tail)[-1]) > 0
        decoded_data = bytes_read.partition(tail)[0].decode("utf-8")
        data = yaml.load(decoded_data, Loader=yaml.Loader)
        return data

    def erase_memory(self):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for erasing EEPROM at time %s" % time.ctime())
        try:
            for page in range(512):
                b1, b2 = make_addr_bytes(page=page, byte=0)
                self.port.write([b1, b2] + [0xFF] * 64)
                if page % 10 == 0:
                    print(
                        "Erasing EEPROM: %d%% done" % (page / 5.12),
                        end="                 \r",
                    )
            print("Erasing EEPROM complete")
        finally:
            self.device.lock_ftdi.release()

    def read_eeprom(self):
        if self.using_filewriter:
            return self._read_from_file()
        pages_read = []
        tail = bytearray([0xFF] * 63)
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for reading EEPROM at time %s" % time.ctime())
        try:
            for page in range(512):
                b1, b2 = make_addr_bytes(page=page, byte=0)
                self.port.write([b1, b2], relax=False)
                bytes_read = self.port.read(64)
                pages_read += bytes_read
                if len(bytes_read.partition(tail)[-1]) > 0:
                    break
                print("Reading EEPROM: content found in %d pages" % (page + 1),end="                    \r",)
        finally:
            self.device.lock_ftdi.release()
        try:
            compressed_data = bytearray(pages_read).partition(tail)[0]
            loaded_data = gzip.decompress(compressed_data)
            loaded_data = loaded_data.decode("utf-8")
            loaded_data = yaml.load(loaded_data, Loader=yaml.Loader)
        except Exception:
            traceback.print_exc()
            print("Pages read:", pages_read)
            print("Compressed data:", compressed_data)
            self.using_filewriter = True
            print("Falling back to file writer")
            return self._read_from_file()
        self._write_to_file(loaded_data)
        return loaded_data

    def test_memory(self):
        page = self.PAGE_TEST
        test_data = list(np.random.randint(0, 255, 64))
        b1, b2 = make_addr_bytes(page=page, byte=0)
        self.port.write([b1, b2] + test_data)
        self.port.write([b1, b2], relax=False)
        bytes_read = self.port.read(64)
        if [i for i in bytes_read] == test_data:
            return True
        else:
            print("EEPROM memory error")
            return False


--- flask_app/minimal_device/lasers.py ---
import pyftdi.i2c
import time


def set_bit(v, index, x):  # source: stackoverflow.com/questions/12173774/
    """Set the index:th bit of v to 1 if x is truthy, else to 0, and return the new value."""
    mask = 1 << index  # Compute mask, an integer with just bit 'index' set.
    v &= ~mask  # Clear the bit indicated by the mask (if x is False)
    if x:
        v |= mask  # If x was True, set the bit indicated by the mask.
    return v  # Return the result, we're done.


class Lasers:
    registers = {1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 3, 7: 3}
    bits = {1: 1, 2: 3, 3: 5, 4: 7, 5: 1, 6: 3, 7: 5}

    def __init__(self, device):
        self.device = device
        self.multiplexer_port = None

        if self.device.is_connected():
            self.connect()

    def connect(self):
        try:
            self.multiplexer_port = self.device.i2c.get_port(
                self.device.PORT_GPIO_MULTIPLEXER_LASERS
            )
            self.multiplexer_port.write_to(6, [0x00])  # set all GPIO pins as output
            self.multiplexer_port.write_to(7, [0x00])  # set all GPIO pins as output
        except pyftdi.i2c.I2cNackError:
            print("PCA9555 laser multiplexer connection ERROR.")

    def switch_on(self, vial):
        register = self.registers[vial]
        bit = self.bits[vial]
        old_byte = self.multiplexer_port.read_from(register, 1)[
            0
        ]  # read which lasers are currently shining
        new_byte = set_bit(old_byte, bit, 0)
        self.multiplexer_port.write_to(register, [new_byte])

    def switch_off(self, vial):
        register = self.registers[vial]
        bit = self.bits[vial]
        old_byte = self.multiplexer_port.read_from(register, 1)[
            0
        ]  # read which lasers are currently shining
        new_byte = set_bit(old_byte, bit, 1)
        self.multiplexer_port.write_to(register, [new_byte])

    def switch_all_on(self):
        self.multiplexer_port.write_to(2, [0b00000000])
        self.multiplexer_port.write_to(3, [0b00000000])

    def switch_all_off(self):
        self.multiplexer_port.write_to(2, [0b11111111])
        self.multiplexer_port.write_to(3, [0b11111111])

    def blink(self):
        for i in range(3):
            self.switch_all_on()
            time.sleep(0.08)
            self.switch_all_off()
            time.sleep(0.04)


--- flask_app/minimal_device/led.py ---

import threading
import time
import pyftdi.i2c


class RGBLedController:
    """Controller for RGB LEDs using PCA9685 on two I2C addresses."""

    def __init__(self, device, frequency=50):
        """
        Initialize the RGB LED controller.
        :param device: Device object with an I2C interface
        :param frequency: PWM frequency (default: 50Hz)
        """
        self.device = device
        self.frequency = frequency
        self.lock = threading.Lock()

        # Ports for the two PCA9685 controllers
        self.port_rgb_pwm1 = None  # LEDs 1-5
        self.port_rgb_pwm2 = None  # LEDs 6-7

        if self.device.is_connected():
            self.connect()

    def connect(self):
        """Establish connections to the PCA9685 controllers and configure them."""
        try:
            # Connect to the first PCA9685 (LEDs 1-5)
            self.port_rgb_pwm1 = self.device.i2c.get_port(self.device.PORT_RGB_PWM1)
            self._initialize_pwm_controller(self.port_rgb_pwm1)

            # Connect to the second PCA9685 (LEDs 6-7)
            self.port_rgb_pwm2 = self.device.i2c.get_port(self.device.PORT_RGB_PWM2)
            self._initialize_pwm_controller(self.port_rgb_pwm2)

            print("Connected to both PCA9685 RGB controllers")
        except Exception as e:
            print("Error connecting to PCA9685 controllers:", e)

    def _initialize_pwm_controller(self, port):
        """Initialize a PCA9685 controller."""
        self._set_frequency(port, self.frequency)
        self._set_all_leds(port, 0, 0, 0)  # Turn off all LEDs initially

    def _set_frequency(self, port, frequency):
        """Set the PWM frequency on a specific PCA9685 port."""
        pre_scale = round(25000000 / (4096 * frequency)) - 1
        with self.lock:
            port.write_to(0x00, [0x10])  # Enter sleep mode
            port.write_to(0xFE, [pre_scale])  # Set frequency
            port.write_to(0x00, [0x80])  # Restart in normal mode

    def set_led(self, led_number, red, green, blue):
        """
        Set the brightness of an RGB LED.
        :param led_number: LED index (starting from 1)
        :param red: Brightness for red (0-1)
        :param green: Brightness for green (0-1)
        :param blue: Brightness for blue (0-1)
        """
        assert 1 <= led_number <= 7
        assert 0 <= red <= 1 and 0 <= green <= 1 and 0 <= blue <= 1

        if 1 <= led_number <= 5:
            port = self.port_rgb_pwm1
            base_pin = (led_number - 1) * 3
        else:
            port = self.port_rgb_pwm2
            base_pin = (led_number - 6) * 3

        self._set_rgb_pwm(port, base_pin, red, green, blue)

    def _set_rgb_pwm(self, port, base_pin, red, green, blue):
        """Set the PWM values for an RGB LED."""
        self._set_pwm(port, base_pin + 1, red)
        self._set_pwm(port, base_pin + 2, green)
        self._set_pwm(port, base_pin, blue)

    def _set_pwm(self, port, pin, duty_cycle):
        """Set the PWM duty cycle for a specific pin on a given port."""
        msb, lsb = divmod(round(4095 * duty_cycle), 0x100)
        with self.lock:
            # port.write_to(0x06 + pin * 4, [0x00])  # ON low byte
            # port.write_to(0x07 + pin * 4, [0x00])  # ON high byte
            port.write_to(0x08 + pin * 4, [lsb])   # OFF low byte
            port.write_to(0x09 + pin * 4, [msb])   # OFF high byte

    def set_all_leds(self, red, green, blue):
        """
        Set all RGB LEDs to the same color.
        :param red: Brightness for red (0-1)
        :param green: Brightness for green (0-1)
        :param blue: Brightness for blue (0-1)
        """
        self._set_all_leds(self.port_rgb_pwm1, red, green, blue)  # LEDs 1-5
        self._set_all_leds(self.port_rgb_pwm2, red, green, blue)  # LEDs 6-7

    def _set_all_leds(self, port, red, green, blue):
        """Set all LEDs connected to a specific port to the same color."""
        for i in range(5 if port == self.port_rgb_pwm1 else 2):
            base_pin = i * 3
            self._set_rgb_pwm(port, base_pin, red, green, blue)

    def blink_hello(self):
        """Blink green LEDs."""
        self.set_all_leds(1, 0, 0) # red
        self.set_all_leds(0, 1, 0) # green
        self.set_all_leds(0, 0, 1) # blue
        self.set_all_leds(1, 1, 1) # white
        time.sleep(0.2)
        self.set_all_leds(0, 0, 0) # off
        time.sleep(0.2)

    def turn_off_all(self):
        """Turn off all LEDs."""
        self.set_all_leds(0, 0, 0)

# Usage example:
# device = BaseDevice()
# rgb_controller = RGBLedController(device)
# rgb_controller.set_led(1, 1, 0, 0)  # Set LED 1 to red
# rgb_controller.set_led(6, 0, 1, 0)  # Set LED 6 to green
# rgb_controller.set_all_leds(0, 0, 1)  # Set all LEDs to blue


--- flask_app/minimal_device/loading.py ---
import inspect
import os
import pickle
import time

import numpy as np
import yaml


def load_config(obj, filepath):
    config = open(filepath).read()
    loaded_dict = yaml.load(config, Loader=yaml.Loader)
    assert (
        loaded_dict["_class"] == obj.__class__
    ), "object class does not match loaded class"
    for k in loaded_dict.keys():
        if k != "directory":
            obj.__dict__[k] = loaded_dict[k]


def load_object(filepath):
    """
    reads a python object from a yaml config
    """
    if not os.path.exists(filepath):
        return None
    else:
        config = open(filepath).read()
        loaded_dict = yaml.load(config, Loader=yaml.Loader)
        klass = loaded_dict["_class"]
        s = inspect.signature(klass.__init__)
        init_args = list(s.parameters.keys())
        init_args = [arg for arg in init_args if arg != "self"]
        kwargs = {
            arg: loaded_dict[arg] for arg in init_args if arg in loaded_dict.keys()
        }
        obj = klass(**kwargs)
        for k in loaded_dict.keys():
            obj.__dict__[k] = loaded_dict[k]

        sep = os.path.sep
        if sep not in filepath:
            sep = os.path.altsep
        assert sep in filepath, "Directory must contain '\\' or '/'"

        directory = os.path.join(*filepath.split(sep)[:-1])
        obj.directory = directory
        return obj


def clean_variable(var):
    if type(var) is dict:
        return {clean_variable(k): clean_variable(var[k]) for k in var.keys()}
    if type(var) is list:
        return [clean_variable(v) for v in var]
    try:
        if np.isfinite(var):
            if type(var) is int:
                return int(var)
            else:
                return float(var)
    except Exception:
        return var


def save_object(obj, filepath):
    d = obj.__dict__.copy()
    d["_class"] = obj.__class__
    d["_saved_on"] = time.ctime()
    omit_keys = ["directory", "logger"]
    for k in omit_keys:
        if k in d.keys():
            del d[k]
    for k in list(d.keys()):
        try:
            pickle.dumps(d[k])
            d[k] = clean_variable(d[k])
        except Exception:
            d.pop(k)
    with open(filepath, "w+") as f:
        f.write(yaml.dump(d))


def save_experiment(exp):
    if exp.device is not None:
        exp.device.save()
    for culture in exp.cultures.values():
        if culture is not None:
            culture.save()


def load_experiment(exp):
    directory = exp.directory
    if not os.path.exists(directory):
        os.mkdir(directory)
        print("Created new experiment directory: %s" % directory)
    else:
        print("Experiment directory: '%s'" % directory)
        # t0 = time.time()
        device_config_path = os.path.join(directory, "device_config.yaml")
        if os.path.exists(device_config_path):
            exp.device = load_object(filepath=device_config_path)
            exp.device.load()  # load cultures
        else:
            print("No device config found.")


--- flask_app/minimal_device/od_sensor.py ---
import os
import time

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt


def od_calibration_function(x, a, b, c, d, g):
    """
    converts signal mV to optical density
    4 Parameter logistic function
    adapted from:
    https://weightinginbayesianmodels.github.io/poctcalibration/calib_tut4_curve_background.html

    :param x: signal voltage in millivolts
    :param a: On the scale of y; horizontal asymptote as x goes to infinity.
    :param b: Hill coefficient
    :param c: Inflection point.
    :param d: On the scale of y; horizontal asymptote as x goes, in theory, to negative infinity,
              but, in practice, to zero.
    :return: y - optical density
    """
    y = d + (a - d) / ((1 + (x / c) ** b) ** g)
    return y


def od_calibration_function_inverse(y, a, b, c, d, g):
    """
    converts optical density to signal mV

    Inverse of 4 Parameter logistic function
    adapted from:
    https://weightinginbayesianmodels.github.io/poctcalibration/calib_tut4_curve_background.html

    :param y: optical density
    :param a: On the scale of y; horizontal asymptote as x goes to infinity.
    :param b: Hill coefficient
    :param c: Inflection point.
    :param d: On the scale of y; horizontal asymptote as x goes, in theory, to negative infinity,
              but, in practice, to zero.
    :return: x - signal voltage in millivolts
    """
    x = c * (((a - d) / (y - d)) ** (1 / g) - 1) ** (1 / b)
    return x


class OdSensor:
    def __init__(self, device, vial_number):
        self.device = device
        self.vial_number = vial_number

    def mv_to_od(self, mv):
        coefs = self.device.device_data['ods']['calibration_coefs'][self.vial_number]
        a, b, c, d, g = coefs
        return od_calibration_function(mv, a, b, c, d, g)

    def measure_transmitted_intensity(self):
        """
        returns the intensity of the transmitted light
        :return:
        """
        self.device.photodiodes.switch_to_vial(vial=self.vial_number)
        self.device.lasers.switch_on(vial=self.vial_number)
        time.sleep(0.02)
        mv, err = self.device.photodiodes.measure(gain=8, bitrate=16)
        self.device.lasers.switch_off(vial=self.vial_number)
        return mv, err

    def measure_background_intensity(self):
        """
        returns the intensity of the background light (no laser)
        :return:
        """
        self.device.photodiodes.switch_to_vial(vial=self.vial_number)
        mv, err = self.device.photodiodes.measure(gain=8, bitrate=16)
        return mv, err

    def log_mv(self, background, transmitted):
        directory = os.path.join(self.device.directory, "vial_%d" % self.vial_number)
        if not os.path.exists(directory):
            os.mkdir(directory)

        filepath = os.path.join(directory, "photodiode_millivolts.csv")
        if not os.path.exists(filepath):
            with open(filepath, "w+") as f:
                f.write("time,transmitted,background\n")
        with open(filepath, "a") as f:
            data_string = "%d,%.4f,%.4f\n" % (int(time.time()), transmitted, background)
            f.write(data_string)

    def measure_signal(self):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock to measure OD signal at time %s" % time.ctime())
        try:
            background = self.measure_background_intensity()[0]
            transmitted = self.measure_transmitted_intensity()[0]
        finally:
            self.device.lock_ftdi.release()
        if self.device.directory is not None:
            self.log_mv(background=background, transmitted=transmitted)
        signal = transmitted - background
        if signal < 0:
            signal = 0
        return signal

    def measure_od(self):
        signal = self.measure_signal()
        od = self.mv_to_od(signal)
        od = float(od)
        self.device.device_data["ods"]['states'][self.vial_number] = od
        self.device.device_data["ods"]['odsignals'][self.vial_number] = signal
        return od, signal

    def measure_od_calibration(self, odValue):
        sig = self.measure_signal()
        self.device.device_data['ods']['calibration'][self.vial_number][odValue] = sig

    def check(self):
        v = self.vial_number
        signal = self.device.od_sensors[v].measure_signal()
        if signal >= 15:
            color = bcolors.OKGREEN
        elif 10 < signal < 15:
            color = bcolors.WARNING
        else:
            color = bcolors.FAIL
        print("vial %d OD sensor: " % v + color + "%.2f mV" % signal + bcolors.ENDC)

    def fit_calibration_function(self):
        calibration_od = np.array(list(self.device.device_data['ods']['calibration'][self.vial_number].keys()))
        calibration_mv = np.array(list(self.device.device_data['ods']['calibration'][self.vial_number].values()))

        mask = np.array([item is not None for item in calibration_mv])
        calibration_mv = calibration_mv[mask]
        calibration_od = calibration_od[mask]

        if len(calibration_mv.shape)==1:
            calibration_mv = np.array([[i,i,i] for i in calibration_mv])
        max_len = len(max(calibration_mv, key=len))
        calibration_mv_filled = np.array(
            [list(i) + [np.nan] * (max_len - len(i)) for i in calibration_mv]
        )
        print(calibration_mv_filled)
        calibration_mv_err = np.nanstd(calibration_mv_filled, 1)
        print(calibration_mv_err)
        # calibration_mv = np.array(list(self.calibration_od_to_mv.values())).mean(1)
        calibration_mv = np.nanmean(calibration_mv_filled, 1)

        calibration_mv_err += 0.01  # allows curve fit with single measurements
        coefs, _ = curve_fit(
            od_calibration_function_inverse,
            calibration_od,
            calibration_mv,
            maxfev=5000,
            p0=(20, 5, 0.07, -0.2, 1),
            bounds=[(3, 0, 0, -0.5, 0), (200, 10, 20, 0.1, 5)],
            sigma=calibration_mv_err,
        )
        coefs = [round(i, 3) for i in coefs]
        coefs = [float(i) for i in coefs]
        print(coefs)
        # a, b, c, d, g = coefs
        self.device.device_data['ods']['calibration_coefs'][self.vial_number] = coefs
        if self.device.is_connected():
            self.device.eeprom.save_config_to_eeprom()
        # self.plot_calibration_curve()

    def plot_calibration_curve(self):

        plt.figure(figsize=[4, 2], dpi=150)

        calibration_od = np.array(list(self.device.device_data['ods']['calibration'][self.vial_number].keys()))
        calibration_mv = np.array(list(self.device.device_data['ods']['calibration'][self.vial_number].values()))
        if len(calibration_mv.shape)==1:
            calibration_mv = np.array([[i,i+0.1,i-0.1] for i in calibration_mv])
        max_len = len(max(calibration_mv, key=len))
        calibration_mv_filled = np.array(
            [list(i) + [np.nan] * (max_len - len(i)) for i in calibration_mv]
        )
        calibration_mv_err = np.nanstd(calibration_mv_filled, 1)
        calibration_mv = np.nanmean(calibration_mv_filled, 1)

        xmin = 0
        xmax = max(max(calibration_mv),140) + 10
        x = np.linspace(xmin, xmax, 501)
        y = self.mv_to_od(x)
        a, b, c, d, g = self.device.device_data['ods']['calibration_coefs'][self.vial_number]
        plt.plot(x, y, "b:", label="function fit")
        plt.title(
            "od_max:%.2f slope: %.2f mv_inflec: %.2f od_min: %.2f, g: %.2f"
            % (a, b, c, d, g),
            fontsize=8,
        )
        #     plt.plot(calibration_mv, calibration_od, "r.")
        plt.errorbar(
            calibration_mv,
            calibration_od,
            xerr=calibration_mv_err,
            fmt="b.",
            label="calibration data",
        )
        plt.xlabel("signal[mV] (background-subtracted)")
        plt.ylabel("OD")
        # plt.ylim([-1, 5])
        plt.axhline(0, ls="--", c="k", lw=0.5)
        # plt.title("Vial %d OD calibration" % self.vial_number, fontsize=8)

        plt.legend()
        plt.show()

class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


--- flask_app/minimal_device/other.py ---
import os
import time


def read_file_tail(filepath, lines=1000, _buffer=4096):
    lines = int(lines)
    with open(filepath, "rb") as f:
        # place holder for the lines found
        lines_found = []

        # block counter will be multiplied by buffer
        # to get the block size from the end
        block_counter = -1

        # loop until we find X lines
        while len(lines_found) < lines + 1:
            try:
                f.seek(block_counter * _buffer, os.SEEK_END)
            except IOError:  # either file is too small, or too many lines requested
                f.seek(0)
                lines_found = f.readlines()
                break
            lines_found = f.readlines()
            # we found enough lines, get out
            # decrement the block counter to get the
            # next X bytes
            block_counter -= 1
    return lines_found


# def read_csv_tail(filepath, lines=1000, _buffer=4096):
#     """Tail a file and get X lines from the end
#     modified from https://stackoverflow.com/questions/136168/get-last-n-lines-of-a-file-similar-to-tail/136368#136368
#     """
#     header = open(filepath).readline().rstrip().split(",")
#     lines_found = read_file_tail(filepath=filepath, lines=lines, _buffer=_buffer)
#
#     lines_found = lines_found[1:]  # cut header if lines > total lines in file
#     lines_found = lines_found[-lines:]
#     lines_found = [
#         line.decode().rstrip().replace(" ", "").split(",") for line in lines_found
#     ]
#     lines_found = np.array(lines_found)
#     data = lines_found[:, 1:]
#     d = []
#     for data_line in data:
#         try:
#             d += [pd.to_numeric(data_line)]
#         except ValueError:
#             line = []
#             for value in data_line:
#                 try:
#                     line += [pd.to_numeric(value)]
#                 except ValueError:
#                     line += [np.nan]
#             d += line
#     data = d
#
#     data = [pd.to_numeric(data_line) for data_line in data]
#     timestamp = lines_found[:, 0]
#
#     df = pd.DataFrame(data, columns=header[1:])
#
#     try:
#         timestamp = pd.to_numeric(timestamp)  # 5 ms  for 10 000 lines
#     except ValueError:
#         timestamp = pd.to_datetime(timestamp)  # 1.3 seconds for 10 000 lines
#         timestamp = pd.to_numeric(timestamp)
#
#     df.index = timestamp
#
#     df.index.name = header[0]
#     return df


class CultureDict(dict):
    def __init__(self, device):
        super().__init__()
        self.device = device

    def __setitem__(self, vial, c):
        if c is not None:
            assert os.path.exists(
                self.device.directory
            ), "device directory does not exist:"
            new_culture_directory = os.path.join(
                self.device.directory, "vial_%d" % vial
            )

            existing_config = os.path.join(new_culture_directory, "culture_config.yaml")
            if c.directory is None and os.path.exists(existing_config):
                raise RuntimeError("Culture %d config exists" % vial)
            if not os.path.exists(new_culture_directory):
                os.mkdir(new_culture_directory)
            c.vial_number = vial
            # c.experiment_directory = self.device.directory
            c.directory = new_culture_directory
            c.device = self.device

        super().__setitem__(vial, c)


def write_variable(culture, variable_name, value):
    filepath = os.path.join(culture.directory, "%s.csv" % variable_name)
    if not os.path.exists(filepath):
        with open(filepath, "w+") as f:
            f.write("time,%s\n" % variable_name)
    with open(filepath, "a") as f:
        data_string = "%.1f, %.5f\n" % (int(time.time()), value)
        f.write(data_string)

    # # save variable value to sql lite database
    culture.sql_db.add_variable(variable_name, value)

# initialize sql lite database storing culture parameters and the following variables: experiment state, culture name, species, od, concentration
def init_sql_db(culture):
    import sqlite3
    import os

    db_path = os.path.join(culture.directory, "culture_parameters.db")
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute(
        """CREATE TABLE IF NOT EXISTS culture_parameters (
            culture_name text,
            species text,
            od real,
            concentration real
            )"""
    )
    conn.commit()
    return conn




class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


--- flask_app/minimal_device/pump.py ---
import math

# import matplotlib.pyplot as plt
# import numpy as np
# import pandas as pd
# import scipy.optimize
from scipy.optimize import fsolve

from .stepper import Stepper


# def calibrate_pump(device, pump_number):
#     p = device.pumps[pump_number]
#     n_rotations = float(input("How many rotations?"))
#     n_repetitions = float(input("How many repetitions?"))
#     assert n_repetitions % 1 == 0
#     n_repetitions = int(n_repetitions)
#     total_volume = n_rotations * n_repetitions * 0.1
#     p.fit_calibration_function()
#     if callable(p.calibration_function):
#
#         def opt_function(volume):
#             return p.calibration_function(volume) - n_rotations
#
#         predicted_mls = fsolve(opt_function, 1)[0]
#         predicted_total_mls = predicted_mls * n_repetitions
#         print("Predicted %.2f mls from existing calibration data" % predicted_total_mls)
#         total_volume = predicted_total_mls
#     q = input(
#         "Are ~%d ml available? \nZero the scale and press ENTER; q to exit"
#         % round(total_volume)
#     )
#     if q == "":
#         for i in range(n_repetitions):
#             p.move(n_rotations)
#             print("%d/%d" % (i + 1, n_repetitions), end="\t\r")
#             while p.is_pumping():
#                 time.sleep(0.1)
#             time.sleep(1)
#         ml = float(input("How many mls?"))
#         ml = ml / n_repetitions
#         device.calibration_pump_rotations_to_ml[pump_number][n_rotations] = round(ml, 3)
#         device.save()


def pump_calibration_function(x, a, b, c):
    """
    converts pumped volume (x) to motor rotations(y)
    """
    y = a * x + b * x * math.exp(-c * x)
    return y


class Pump(Stepper):
    def __init__(self, device, cs):
        super().__init__(device=device, cs=cs)

        self.device = device
        self.cs = cs
        self.pump_number = cs + 1
        # self.calibration_function = None

    # @property
    # def coefs(self):
    #     return self.device.calibration_coefs_pumps[self.pump_number]

    # @coefs.setter
    # def coefs(self, value):
    #     self.device.calibration_coefs_pumps[self.pump_number] = list(value)
    #     try:
    #         self.device.save()
    #     except Exception:
    #         pass

    # def calibration_function(self, mL):
    #     if len(self.coefs) < 3:
    #         return None
    #     else:
    #         a, b, c = self.coefs
    #         return pump_calibration_function(mL, a, b, c)

    def show_parameters(self):
        print("pump_number %d stock volume:" % self.pump_number, self.stock_volume)
        print(
            "pump_number %d stock concentration:" % self.pump_number,
            self.stock_concentration,
        )
        # self.calibration_curve()
        # plt.show()

    @property
    def stock_concentration(self):
        return self.device.pump_stock_concentrations[self.pump_number]

    @stock_concentration.setter
    def stock_concentration(self, value):
        value = float(value)
        self.device.pump_stock_concentrations[self.pump_number] = value
        self.device.save()

    @property
    def stock_volume(self):
        return self.device.pump_stock_volumes[self.pump_number]

    @stock_volume.setter
    def stock_volume(self, value):
        value = float(value)
        self.device.pump_stock_volumes[self.pump_number] = value
        self.device.save()

    def calculate_rotations(self, volume):
        # Get the coefficients for the given pumpId
        coefficients = self.device.device_data['pumps']['calibration'][self.pump_number]
        # Convert the coefficients into a list of (rotations, coefficient) pairs and sort
        points = sorted([(int(rot), coef) for rot, coef in coefficients.items()])

        # If volume is larger than the largest known, use the largest coefficient
        if volume >= points[-1][0] * points[-1][1]:
            return volume / points[-1][1]

        # Find the two points surrounding the given volume
        lower_point = points[0]
        upper_point = points[-1]
        for i in range(len(points) - 1):
            if volume >= points[i][0] * points[i][1] and volume <= points[i + 1][0] * points[i + 1][1]:
                lower_point = points[i]
                upper_point = points[i + 1]
                break

        # Calculate the interpolation factor
        lower_volume = lower_point[0] * lower_point[1]
        upper_volume = upper_point[0] * upper_point[1]
        factor = (volume - lower_volume) / (upper_volume - lower_volume)

        # Interpolate the coefficient
        interpolated_coefficient = lower_point[1] + (upper_point[1] - lower_point[1]) * factor

        # Calculate the rotations
        rotations = volume / interpolated_coefficient

        return rotations

    def calculate_volume(self, rotations):
        coefficients = self.device.device_data['pumps']['calibration'][self.pump_number]

        if rotations <= min(coefficients.keys()):
            correction_coefficient = coefficients[min(coefficients.keys())]
        else:
            for i in range(len(coefficients) - 1):
                if list(coefficients.keys())[i] <= rotations < list(coefficients.keys())[i + 1]:
                    correction_coefficient = coefficients[list(coefficients.keys())[i]] + \
                                             (rotations - list(coefficients.keys())[i]) * \
                                             (coefficients[list(coefficients.keys())[i + 1]] - coefficients[
                                                 list(coefficients.keys())[i]]) / \
                                             (list(coefficients.keys())[i + 1] - list(coefficients.keys())[i])
                    break
            else:
                correction_coefficient = coefficients[max(coefficients.keys())]
        volume = rotations * correction_coefficient
        return round(volume, 2)

    def pump(self, volume, rot_per_sec=None):
        rotations = self.calculate_rotations(abs(volume))
        if volume < 0:
            rotations *= -1
        if volume != 0:
            if rot_per_sec is None:
                rot_per_sec = self.max_speed_rps
            self.move(n_rotations=rotations, rot_per_sec=rot_per_sec)

    def get_pumped_volume(self):
        microsteps = self.get_abs_position()
        n_rotations = microsteps / 25600
        vol = self.calculate_volume(n_rotations)
        return vol

    # def add_calibration_point(self, rotations, volume):
    #     temp = self.calibration_rotations_to_ml
    #     temp[rotations] = volume
    #     self.calibration_rotations_to_ml = temp

    # def calibrate(self, rotations_to_ml=None, dummy_data=False):
    #     self.device.save()
    #     self.calibration_rotations_to_ml = rotations_to_ml
    #     if rotations_to_ml is None and dummy_data:
    #         self.calibration_rotations_to_ml = {
    #             1: 0.145,
    #             5: 0.563,
    #             10: 1.012,
    #             20: 2.14,
    #             50: 5.14,
    #             100: 9.21,
    #         }

    # def fit_calibration_function(self):
    #     calibration_n_rotations = sorted(list(self.calibration_rotations_to_ml.keys()))
    #     calibration_volumes = sorted(list(self.calibration_rotations_to_ml.values()))
    #     if calibration_n_rotations is not None:
    #         if len(calibration_n_rotations) >= 4:
    #             coefs, _ = scipy.optimize.curve_fit(
    #                 pump_calibration_function,
    #                 calibration_volumes,
    #                 calibration_n_rotations,
    #                 p0=(10, -10, 1),
    #                 bounds=[(-50, -50, 0.1), (50, 50, 1)],
    #                 sigma=np.array(calibration_volumes) * 0.1,
    #             )
    #             self.coefs = coefs
    #             a, b, c = self.coefs
    #             return a, b, c

    # def calibration_curve(self):
    #     calibration_n_rotations = sorted(list(self.calibration_rotations_to_ml.keys()))
    #     calibration_volumes = sorted(list(self.calibration_rotations_to_ml.values()))
    #     if len(calibration_n_rotations) < 4:
    #         print(
    #             "PUMP %d: NOT ENOUGH CALIBRATION POINTS (%d/4)"
    #             % (self.pump_number, len(calibration_n_rotations))
    #         )
    #     else:
    #         a, b, c = self.fit_calibration_function()
    #         plt.figure(figsize=[6, 4], dpi=100)
    #         x = np.linspace(0, 20, 101)
    #         y = [self.calibration_function(vol) for vol in x]
    #         plt.plot(calibration_volumes, calibration_n_rotations, "bs")
    #         plt.plot(x, y, "k:")
    #         plt.xlabel("pumped volume [mL]")
    #         plt.ylabel("motor rotations")
    #         plt.title(
    #             "Pump %d calibration\n a (slope): %.3f    b: %.3f    c: %.3f"
    #             % (self.pump_number, a, b, c)
    #         )
            # plt.show()

    # def check(self):
    #     # test_failed = False
    #     driver = bcolors.WARNING + "driver, " + bcolors.ENDC
    #     calibration = bcolors.WARNING + "calibration, " + bcolors.ENDC
    #     volume = bcolors.WARNING + "volume, " % self.stock_volume + bcolors.ENDC
    #     concentration = bcolors.WARNING + "concentration" + bcolors.ENDC
    #     if not self.driver_is_responsive():
    #         driver = bcolors.FAIL + "driver not responsive" + bcolors.ENDC
    #         # test_failed = True
    #         print("Pump %d:" % self.pump_number, driver)
    #         return
    #
    #     else:
    #         driver = bcolors.OKGREEN + "driver OK," + bcolors.ENDC
    #         if len(self.coefs) == 0 or pd.isnull(self.calibration_function(1)):
    #             calibration = bcolors.FAIL + "not calibrated," + bcolors.ENDC
    #         else:
    #             calibration = bcolors.OKGREEN + "calibration OK," + bcolors.ENDC
    #             # test_failed = True
    #
    #         if pd.isnull(self.stock_volume):
    #             volume = bcolors.FAIL + "volume unknown," + bcolors.ENDC
    #             # test_failed = True
    #         else:
    #             volume = bcolors.OKGREEN + "%d ml," % self.stock_volume + bcolors.ENDC
    #
    #         if not pd.isnull(self.stock_concentration):
    #             concentration = (
    #                 bcolors.OKGREEN
    #                 + "concentration: %.2f" % self.stock_concentration
    #                 + bcolors.ENDC
    #             )
    #             # test_failed = True
    #         else:
    #             concentration = bcolors.FAIL + "concentration unknown" + bcolors.ENDC
    #
    #     # if not test_failed:
    #     #     print("Pump %d " % self.pump_number + bcolors.OKGREEN + "OK" + bcolors.ENDC)

        # print(
        #     "Pump %d:" % self.pump_number,
        #     driver,
        #     calibration,
        #     volume,
        #     concentration,
        # )


--- flask_app/minimal_device/pwm.py ---
import threading
import time
import traceback

import pyftdi.i2c


class PwmController:
    """PCA9685 PWM controller"""

    def __init__(self, device, frequency=50):
        self.device = device
        self.frequency = frequency
        self.lock = (threading.Lock())  # valves and stirrers can be used on different threads
        self.port = None
        if self.device.is_connected():
            self.connect()

    def connect(self):
        """
        Establish I2C connection to the PWM controller.
        :return:
        """

        try:
            for i in range(3):
                try:
                    self.port = self.device.i2c.get_port(self.device.PORT_PWM)
                    break
                except Exception as e:
                    traceback.print_exc()
                    print("PCA9685 PWM controller connection ERROR:", e)
                    time.sleep(1)
            print("Connected to PCA9685 PWM controller port", self.port)
            self.set_frequency(self.frequency)
            self.stop_all()
            self.write_all_zeros()
            self.stop_all()
            self.set_duty_cycle_all(0)
            self.set_frequency(self.frequency)
        except pyftdi.i2c.I2cNackError:
            self.port = None
            print("PCA9685 PWM controller connection ERROR. exiting connect()")

    def write_all_zeros(self):
        all_led_on_l = 250
        all_led_on_h = 251
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock to connect PWM controller at time %s" % time.ctime())
        try:
            self.port.write_to(all_led_on_l, [0x0])
            self.port.write_to(all_led_on_h, [0x00])
        finally:
            self.device.lock_ftdi.release()

    def set_frequency(self, frequency):
        """
        Set the PWM frequency.
        :param frequency:
        :return:
        """
        pre_scale = round(25000000 / (4096 * frequency)) - 1

        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for set_frequency at time %s" % time.ctime())
        try:
            try:
                self.port.write_to(0x00, [0b00010001])  # sleep mode
            except Exception:
                time.sleep(0.5)
                self.port.write_to(0x00, [0b0])  # reset
                print("Reset PWM driver")
                self.port.write_to(0x00, [0b00010001])  # sleep mode
            self.port.write_to(0xFE, [pre_scale])  # SET_PWM_FREQUENCY
            self.port.write_to(0x00, [0b10000001])  # restart mode
        finally:
            self.device.lock_ftdi.release()

    def get_duty_cycle(self, led_number):
        """
        Get the duty cycle of a given pin number.
        :param led_number:
        :return:
        """
        led_off_l = led_number * 4 + 8
        led_off_h = led_number * 4 + 9

        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for get_duty_cycle at time %s" % time.ctime())
        try:
            lsbr = self.port.read_from(led_off_l, 1)[0]
            msbr = self.port.read_from(led_off_h, 1)[0]
            duty_cycle_read = ((msbr << 8) + lsbr) / 4095
            return duty_cycle_read
        finally:
            self.device.lock_ftdi.release()

    def set_duty_cycle(self, led_number, duty_cycle):
        """
        Set the duty cycle of a given pin number.
        :param led_number:
        :param duty_cycle:
        :return:
        """
        assert 0 <= led_number <= 15
        assert 0 <= duty_cycle <= 1
        msb, lsb = divmod(
            round(4095 * duty_cycle), 0x100
        )  # most and least significant bytes
        led_off_l = led_number * 4 + 8
        led_off_h = led_number * 4 + 9

        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for set_duty_cycle at time %s" % time.ctime())
        try:
            self.port.write_to(led_off_l, [lsb])
            self.port.write_to(led_off_h, [msb])
        finally:
            self.device.lock_ftdi.release()

    def set_duty_cycle_all(self, duty_cycle):
        """
        Set the duty cycle of all pins.
        :param duty_cycle: 0-1
        """
        msb, lsb = divmod(
            round(4095 * duty_cycle), 0x100
        )  # most and least significant bytes
        all_led_off_l = 252
        all_led_off_h = 253

        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for set_duty_cycle_all at time %s" % time.ctime())
        try:
            self.port.write_to(all_led_off_l, [lsb])
            self.port.write_to(all_led_off_h, [msb])
        finally:
            self.device.lock_ftdi.release()

    def stop_all(self):
        """
        Stop all PWM signals.
        :return:
        """
        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for stop_all at time %s" % time.ctime())
        try:
            self.port.write_to(0x00, [0b10001])
        finally:
            self.device.lock_ftdi.release()

    def start_all(self):
        """
        Start all PWM signals.
        :return:
        """
        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for start_all at time %s" % time.ctime())
        try:
            self.port.write_to(0x00, [0b00001])
            time.sleep(0.002)
            self.port.write_to(0x00, [0b10000001])
        finally:
            self.device.lock_ftdi.release()

    def is_sleeping(self):
        """
        Check if the PWM controller is sleeping.
        :return:
        """
        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire i2c port lock for is_sleeping at time %s" % time.ctime())
        try:
            mode1_register = self.port.read_from(0x00, 1)[0]
        finally:
            self.device.lock_ftdi.release()
        is_sleeping = bool(int(bin(mode1_register)[2:].rjust(8, "0")[-5]))  # sleep bit
        return is_sleeping

    def play_turn_on_sound(self):
        """
        Play the turn on sound.
        :return:
        """
        base_freq = self.frequency
        self.stop_all()
        self.set_duty_cycle_all(0.01)
        self.set_frequency(261.63)
        self.start_all()
        # self.device.lasers.switch_all_on()
        # i = 0
        time.sleep(0.1)
        for freq in [329.63, 392, 523.25]:
            self.set_frequency(freq)
            # i += 1
            # if i % 2 == 0:
            # self.device.lasers.switch_all_on()
            # else:
            # self.device.lasers.switch_all_off()
            time.sleep(0.15)
        time.sleep(0.15)
        # self.device.lasers.switch_all_off()
        self.stop_all()
        self.set_duty_cycle_all(0)
        self.set_frequency(base_freq)


--- flask_app/minimal_device/stepper.py ---
import math
import time

def split_bytes(value, n_bits, n_bytes):
    assert 0 <= value <= 1
    value = int(value * (2**n_bits - 1))
    value = max(1, value)
    assert value < 2**n_bits

    bytes_list = [0b00] * n_bytes
    for i in range(n_bytes):
        lsb = value & ((1 << 8) - 1)
        value = value >> 8
        bytes_list[i] = lsb
    bytes_list = bytes_list[::-1]
    return bytes_list


class Stepper:
    REGISTER_ABS_POS = 0x01  # Current position, 22 bits
    REGISTER_EL_POS = 0x02  # Electrical position, 9 bits
    REGISTER_MARK = 0x03  # Mark position, 22 bits
    REGISTER_SPEED = 0x04  # Current speed, 20 bits
    REGISTER_ACC = 0x05  # Acceleration, 12 bits
    REGISTER_DEC = 0x06  # Deceleration, 12 bits
    REGISTER_MAX_SPEED = 0x07  # Maximum speed, 10 bits
    REGISTER_MIN_SPEED = 0x08  # Minimum speed, 13 bits
    REGISTER_FS_SPD = 0x15  # Full-step speed, 10 bits
    REGISTER_KVAL_HOLD = 0x09  # Holding KVAL, 8 bits
    REGISTER_KVAL_RUN = 0x0A  # Constant speed KVAL, 8 bits
    REGISTER_KVAL_ACC = 0x0B  # Acceleration starting KVAL, 8 bits
    REGISTER_KVAL_DEC = 0x0C  # Deceleration starting KVAL, 8 bits
    REGISTER_INT_SPEED = 0x0D  # Intersect speed, 14 bits
    REGISTER_ST_SLP = 0x0E  # Start slope, 8 bits
    REGISTER_FN_SLP_ACC = 0x0F  # Acceleration final slope, 8 bits
    REGISTER_FN_SLP_DEC = 0x10  # Deceleration final slope, 8 bits
    REGISTER_K_THERM = 0x11  # Thermal compensation factor, 4 bits
    REGISTER_ADC_OUT = 0x12  # ADC output, 5 bits
    REGISTER_OCD_TH = 0x13  # OCD threshold, 4 bits
    REGISTER_STALL_TH = 0x14  # STALL threshold, 7 bits
    REGISTER_STEP_MODE = 0x16  # Step mode, 8 bits
    REGISTER_ALARM_EN = 0x17  # Alarm enable, 8 bits
    REGISTER_CONFIG = 0x18  # IC configuration, 16 bits
    REGISTER_STATUS = 0x19  # Status, 16 bits

    COMMAND_RESET_DEVICE = 0b11000000  # Device is reset to power-up conditions
    COMMAND_SOFT_STOP = 0b10110000  # Stops motor with a deceleration phase
    COMMAND_HARD_STOP = 0b10111000  # Stops motor immediately
    COMMAND_SOFT_HIZ = 0b10100000  # Puts the bridges into high impedance status after a deceleration phase
    COMMAND_HARD_HIZ = 0b10101000  # Puts the bridges into high impedance status immediately
    COMMAND_GET_STATUS = 0b11010000  # Returns the STATUS register value

    min_speed_rps = 0.01
    max_speed_rps = 4
    acceleration = 0.01
    deceleration = 0.01
    full_step_speed = 0.1
    stall_threshold = 0.5
    _kval_hold = 0
    _kval_run = 0.8
    _kval_acc = 0.57
    _kval_dec = 0.3

    def __init__(self, device, cs):
        self.device = device
        self.cs = cs
        self.port = None
        self.step_mode = None

    def reset_device(self):
        self.port.write([self.COMMAND_RESET_DEVICE])

    def soft_stop(self):
        self.port.write([self.COMMAND_SOFT_STOP])

    def hard_stop(self):
        self.port.write([self.COMMAND_HARD_STOP])

    def soft_hiz(self):
        self.port.write([self.COMMAND_SOFT_HIZ])

    def hard_hiz(self):
        self.port.write([self.COMMAND_HARD_HIZ])

    def get_status_command(self):
        self.port.write([self.COMMAND_GET_STATUS])
        # Assuming the status needs to be read back
        status = self.port.read(2)
        return status

    @property
    def kval_hold(self):
        return self._kval_hold

    @kval_hold.setter
    def kval_hold(self, value):
        assert 0 <= value <= 1
        self.write_register(self.REGISTER_KVAL_HOLD, value=value, n_bits=7, n_bytes=1)
        self._kval_hold = value

    @property
    def kval_acc(self):
        return self._kval_acc

    @kval_acc.setter
    def kval_acc(self, value):
        assert 0 <= value <= 1
        self.write_register(self.REGISTER_KVAL_ACC, value=value, n_bits=7, n_bytes=1)
        self._kval_acc = value

    @property
    def kval_dec(self):
        return self._kval_dec

    @kval_dec.setter
    def kval_dec(self, value):
        assert 0 <= value <= 1
        self.write_register(self.REGISTER_KVAL_DEC, value=value, n_bits=7, n_bytes=1)
        self._kval_dec = value

    @property
    def kval_run(self):
        return self._kval_run

    @kval_run.setter
    def kval_run(self, value):
        assert 0 <= value <= 1
        self.write_register(self.REGISTER_KVAL_RUN, value=value, n_bits=7, n_bytes=1)
        self._kval_run = value

    def set_stall_threshold_ma(self, current_ma):
        """
        set the stall threshold in mA
        """
        # 0000000 is 31.25 mA and 1111111 is 4000 mA
        value = current_ma / 4000
        assert 0 <= value <= 1
        self.stall_threshold = value
        self.write_register(self.REGISTER_STALL_TH, value=self.stall_threshold, n_bits=7, n_bytes=1)

    def detect_stall(self, verbose=False):
        status_register = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        status_byte_high = status_register[0]  # First byte for bits 8-15

        step_loss_a = not (status_byte_high >> 5) & 0b1  # Bit 13
        step_loss_b = not (status_byte_high >> 6) & 0b1  # Bit 14
        if verbose:
            if step_loss_a:
                print("Stall detected on bridge A")
            elif step_loss_b:
                print("Stall detected on bridge B")
            else:
                print("No stall detected")
        return step_loss_a or step_loss_b

    def print_register_meanings(self):
        status_register = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        status_byte_high = status_register[0]  # First byte for bits 8-15
        status_byte_low = status_register[1]  # Second byte for bits 0-7

        meanings = {
            0: ("HiZ", "True" if (status_byte_low >> 0) & 0b1 else "False"),
            1: ("BUSY", "True" if (status_byte_low >> 1) & 0b1 else "False"),
            2: ("SW_F", "Closed" if (status_byte_low >> 2) & 0b1 else "Open"),
            3: ("SW_EVN", "True" if (status_byte_low >> 3) & 0b1 else "False"),
            4: ("DIR", "Clockwise" if (status_byte_low >> 4) & 0b1 else "Counter-clockwise"),
            5: ("MOT_STATUS", "Active" if (status_byte_low >> 5) & 0b1 else "Inactive"),
            6: ("NOTPERF_CMD", "True" if (status_byte_low >> 6) & 0b1 else "False"),
            7: ("WRONG_CMD", "True" if (status_byte_low >> 7) & 0b1 else "False"),
            8: ("UVLO", "False" if (status_byte_high >> 0) & 0b1 else "True"),
            9: ("TH_WRN", "False" if (status_byte_high >> 1) & 0b1 else "True"),
            10: ("TH_SD", "False" if (status_byte_high >> 2) & 0b1 else "True"),
            11: ("OCD", "False" if (status_byte_high >> 3) & 0b1 else "True"),
            12: ("STEP_LOSS_A", "False" if (status_byte_high >> 5) & 0b1 else "True"),
            13: ("STEP_LOSS_B", "False" if (status_byte_high >> 6) & 0b1 else "True"),
            14: ("SCK_MOD", "True" if (status_byte_high >> 7) & 0b1 else "False"),
        }

        print("STATUS REGISTER MEANINGS:")
        print("-" * 30)

        for bit in range(16):
            if bit in meanings:
                bit_name, bit_value = meanings[bit]
                print(f"{bit_name}: {bit_value}")

        print("-" * 30)

    def reset_speeds(self):
        self.write_register(
            self.REGISTER_FS_SPD, value=self.full_step_speed, n_bits=10, n_bytes=2
        )  # k value const
        self.write_register(
            self.REGISTER_STALL_TH, value=self.stall_threshold, n_bits=6, n_bytes=1
        )

        self.kval_hold = self._kval_hold
        self.kval_acc = self._kval_acc
        self.kval_run = self._kval_run
        # self.write_register(self.REGISTER_KVAL_HOLD, value=self.kval_hold, n_bits=7, n_bytes=1)
        # self.write_register(self.REGISTER_KVAL_RUN, value=self.kval_run, n_bits=7, n_bytes=1)
        # self.write_register(self.REGISTER_KVAL_ACC, value=self.kval_acc, n_bits=7, n_bytes=1)

        self.set_min_speed(rot_per_sec=self.min_speed_rps)
        self.set_max_speed(rot_per_sec=self.max_speed_rps)
        self.set_acceleration(value=self.acceleration)
        self.set_deceleration(value=self.deceleration)


    def connect(self):
        self.port = self.device.spi.get_port(cs=self.cs, freq=1e4, mode=3)
        self.port.set_mode(3)
        self.reset_speeds()

    def set_acceleration(self, value=1e-4):
        self.write_register(self.REGISTER_ACC, value=value, n_bits=12, n_bytes=2)

    def set_deceleration(self, value=1e-3):
        self.write_register(self.REGISTER_DEC, value=value, n_bits=12, n_bytes=2)

    def set_min_speed(self, rot_per_sec=0.1):
        # steps_per_sec = integer * 2**-24/250e-9   # page 43 in L6470H datasheet
        correction_factor = 1.322
        rot_per_sec = rot_per_sec * correction_factor
        steps_per_sec = rot_per_sec * 2**22 / 25600
        integer = steps_per_sec * 250e-9 / 2**-24
        self.write_register(self.REGISTER_MIN_SPEED, value=integer / 2**12, n_bits=12, n_bytes=2)

    def set_max_speed(self, rot_per_sec=4.0):
        correction_factor = 1.322
        rot_per_sec = rot_per_sec * correction_factor
        steps_per_sec = rot_per_sec * 2**22 / 25600  # page 43 in L6470H datasheet
        integer = steps_per_sec * 250e-9 / 2**-18
        self.write_register(self.REGISTER_MAX_SPEED, value=integer / 2**10, n_bits=10, n_bytes=2)

    def write_register(self, reg, value, n_bits, n_bytes):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for writing stepper %d register %s" % (self.cs, reg))
        try:
            set_param = reg | 0b00000000
            self.port.write([set_param])  # do not use write_to_port here - lock is already acquired
            bytes_to_write = split_bytes(value, n_bits, n_bytes)
            # print("Writing to register %s: %s" % (reg, bytes_to_write))
            for b in bytes_to_write:
                self.port.write([b])
                time.sleep(0.001)
        finally:
            self.device.lock_ftdi.release()
        bytes_read = self.read_register(reg=reg, n_bytes=n_bytes)
        if not [bytes_to_write[i] == bytes_read[i] for i in range(n_bytes)]:
            print("WARNING: register %s not set correctly" % reg)

    def read_register(self, reg, n_bytes=3):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for reading stepper %d register %s" % (self.cs, reg))
        try:
            get_param = reg | 0b00100000
            self.port.write([get_param])
            res = []
            for b in range(n_bytes):
                res += self.port.read(1)
        finally:
            self.device.lock_ftdi.release()
        return res

    def move(self, n_rotations=1, rot_per_sec=None):
        """
        move the given number of rotations
        By default uses 1/128 microstepping to minimize noise and vibration.
        If number of required microsteps can not fit in the register (> 2^22),
        the step mode is decreased to 1/64 or lower.
        """
        # if n_rotations <= 1:
        #     self.set_max_speed(rot_per_sec=0.1)
        # else:
        #     self.set_max_speed(rot_per_sec=self.max_speed_rps)

        if rot_per_sec is None:
            rot_per_sec = self.max_speed_rps
        self.set_max_speed(rot_per_sec=rot_per_sec)

        if self.step_mode != 7:
            self.set_step_mode(7)
        assert not self.is_pumping(), "Pump %d is already running." % (self.cs + 1)
        if n_rotations >= 0:
            direction_bit = 0b1
        else:
            direction_bit = 0b0

        move_header_byte = 0b01000000 | direction_bit
        max_n_microsteps = 2**22 - 1  # 22 bit

        steps_per_rotation = 200
        microsteps_per_step = 2**self.step_mode
        n_microsteps = abs(n_rotations) * steps_per_rotation * microsteps_per_step

        if n_microsteps > max_n_microsteps:
            required_step_mode = (
                self.step_mode - 1 - int(math.log2(n_microsteps / max_n_microsteps))
            )
            self.set_step_mode(required_step_mode)
            microsteps_per_step = 2**self.step_mode
            n_microsteps = abs(n_rotations) * steps_per_rotation * microsteps_per_step

        write_bytes = split_bytes(n_microsteps / max_n_microsteps, 22, 3)
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for moving stepper %d at time %s" % (self.cs, time.ctime()))
        try:
            self.port.write([move_header_byte])
            for b in write_bytes:
                self.port.write([b])
        finally:
            self.device.lock_ftdi.release()

    def get_abs_position(self):
        microsteps = int.from_bytes(self.read_register(self.REGISTER_ABS_POS), "big")
        return microsteps

    def run(self, speed=0.001):
        """
        run indefinitely at constant speed
        """
        if self.step_mode != 7:
            self.set_step_mode(7)

        if speed >= 0:
            direction_bit = 0b1
        else:
            direction_bit = 0b0
        speed = abs(speed)
        # steps_per_sec = speed*2e-28/250e-9
        run_header_byte = 0b01010000 | direction_bit
        write_bytes = split_bytes(speed, 20, 3)
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for running stepper %d at time %s" % (self.cs, time.ctime()))
        try:
            self.port.write([run_header_byte])
            for b in write_bytes:
                self.port.write([b])
        finally:
            self.device.lock_ftdi.release()

    def is_busy(self):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for checking busy status of stepper %d at time %s" % (self.cs, time.ctime()))
        try:
            self.port.write([0b11010000])
        finally:
            self.device.lock_ftdi.release()
        msb, lsb = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        busy = not (lsb >> 1 & 0b1)
        return busy

    def driver_is_responsive(self):
        if self.port is None:
            return False
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for checking driver responsiveness of stepper %d" % self.cs)
        try:
            self.port.write([0x19])  # GetStatus command, resets warning flags
        except Exception:
            return False
        finally:
            self.device.lock_ftdi.release()

        msb, lsb = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        return not (msb == 255 and lsb == 255)

    def write_to_port(self, data):
        lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not lock_acquired:
            raise Exception("Could not acquire lock for writing to stepper %d" % self.cs)
        try:
            self.port.write(data)
        finally:
            self.device.lock_ftdi.release()

    def is_pumping(self):
        if not self.driver_is_responsive():
            return False
        self.write_to_port([0b11010000])  # GetStatus command, resets warning flags
        msb, lsb = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        status = lsb >> 5 & 0b11
        return status > 0

    def is_hiz(self):
        msb, lsb = self.read_register(self.REGISTER_STATUS, n_bytes=2)
        hiz = bool(lsb & 0b1)
        return hiz

    def stop(self):
        """
        decelerate with programmed deceleration value until the MIN_SPEED value
        is reached and then stop the motor
        """
        # self.port.write([0b10110000])
        self.write_to_port([0b10110000])

    def stop_hard(self):
        """
        stop the motor instantly, ignoring deceleration constraints
        """
        self.write_to_port([0b10111000])
        # self.port.write([0b10111000])

    def reset(self):
        # self.port.write([0b11000000])
        self.write_to_port([0b11000000])
        self.__init__(device=self.device, cs=self.cs)

    def set_step_mode(self, mode=7):
        """
        See page 48 in L6470H datasheet

        0: Full-step
        1: Half-step
        2: 1/4 microstep
        3: 1/8 microstep
        4: 1/16 microstep
        5: 1/32 microstep
        6: 1/64 microstep
        7: 1/128 microstep
        """
        assert mode in [0, 1, 2, 3, 4, 5, 6, 7]
        assert not self.is_pumping(), "can't set step mode while pumping"
        self.hard_hiz()
        # self.port.write([self.REGISTER_STEP_MODE])
        # self.port.write([mode])
        self.write_to_port([self.REGISTER_STEP_MODE])
        self.write_to_port([mode])
        read_mode = self.read_register(self.REGISTER_STEP_MODE)[0]
        if mode != read_mode:
            print("WARNING: step mode not set correctly")
            self.reset()
        self.step_mode = mode

    def get_status(self, verbose=False, reset=False):
        msb, lsb = self.read_register(self.REGISTER_STATUS, n_bytes=2)

        bits = [msb >> i & 1 for i in range(8)[::-1]]
        names = [
            "SCK_MOD",
            "STEP_LOSS_B",
            "STEP_LOSS_A",
            "OCD",
            "TH_SD",
            "TH_WRN",
            "UVLO",
            "WRONG_CMD",
        ]
        byte2 = dict(zip(names, bits))

        bits = [lsb >> i & 1 for i in range(8)[::-1]]
        names = [
            "NOTPERF_CMD",
            "MOT_STATUS1",
            "MOT_STATUS2",
            "DIR",
            "SW_EVN",
            "SW_F",
            "BUSY",
            "HiZ",
        ]
        byte1 = dict(zip(names, bits))

        # status = {0b00: "stopped",
        #           0b01: "accelerating",
        #           0b10: "decelerating",
        #           0b11: "moving at constant speed"}
        # motor_status_string = status[lsb >> 5 & 0b11]

        status_dict = {
            (False, False): "stopped",
            (False, True): "accelerating",
            (True, False): "decelerating",
            (True, True): "constant speed",
        }

        byte1["NOTPERF_CMD"] = bool(byte1["NOTPERF_CMD"])
        byte1["MOT_STATUS1"] = bool(byte1["MOT_STATUS1"])
        byte1["MOT_STATUS2"] = bool(byte1["MOT_STATUS2"])
        byte1["MOT_STATUS"] = status_dict[(byte1["MOT_STATUS1"], byte1["MOT_STATUS2"])]
        del byte1["MOT_STATUS1"]
        del byte1["MOT_STATUS2"]

        byte1["DIR"] = {1: "forward", 0: "reverse"}[byte1["DIR"]]
        byte1["SW_EVN"] = bool(byte1["SW_EVN"])
        byte1["SW_F"] = bool(byte1["SW_F"])
        byte1["BUSY"] = not bool(byte1["BUSY"])
        byte1["HiZ"] = bool(byte1["HiZ"])

        byte2["SCK_MOD"] = bool(byte2["SCK_MOD"])
        byte2["STEP_LOSS_B"] = not bool(byte2["STEP_LOSS_B"])
        byte2["STEP_LOSS_A"] = not bool(byte2["STEP_LOSS_A"])
        byte2["OCD"] = not bool(byte2["OCD"])
        byte2["TH_SD"] = not bool(byte2["TH_SD"])
        byte2["TH_WRN"] = not bool(byte2["TH_WRN"])
        byte2["UVLO"] = not bool(byte2["UVLO"])
        byte2["WRONG_CMD"] = bool(byte2["WRONG_CMD"])

        description = {
            "HiZ": "High Impedance",
            "BUSY": "Busy",
            # "SW_F": "external switch status",
            # "SW_EVN": "external switch turn-on event was detected",
            "DIR": "Direction ",
            "MOT_STATUS": "Motor status",
            "NOTPERF_CMD": "Command received by SPI cannot be performed",
            "WRONG_CMD": "Command received by SPI does not exist",
            "UVLO": "Undervoltage Lockout (8.2 ± 0.7V)",
            "TH_WRN": "Thermal warning (130°C)",
            "TH_SD": "Thermal shutdown (160°C)",
            "OCD": "Overcurrent detection",
            "STEP_LOSS_A": "Stall is detected on bridge A",
            "STEP_LOSS_B": "Stall is detected on bridge B",
            "SCK_MOD": "Working in Step-clock mode",
        }


        s = {}
        s.update({"CS": self.cs})
        s.update(byte1)
        s.update(byte2)
        if reset:
            # self.port.write([0b11010000])
            self.write_to_port([0b11010000])
        if verbose:
            text = ""
            for k in list(description.keys()):
                v = description[k]
                if s[k] is False:
                    color = bcolors.OKGREEN
                elif s[k] is True:
                    color = bcolors.FAIL
                else:
                    color = bcolors.OKBLUE
                text += color + "%s: %s" % (v, s[k]) + bcolors.ENDC + "\n"
            return text
        else:
            return s

class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


--- flask_app/minimal_device/stirrers.py ---
import os
import re
import time
import numpy as np

class Stirrers:
    led_numbers = {stirrer: 7 - stirrer for stirrer in [1, 2, 3, 4, 5, 6, 7]}

    def __init__(self, device):
        self.freq=1e5
        self.device = device
        self.pwm_controller = None
        self.multiplexer_port = None
        self.rpms = {vial: None for vial in range(1, 8)}

        if self.device.is_connected():
            self.connect()

    def connect(self):
        self.pwm_controller = self.device.pwm_controller
        if self.pwm_controller.port is not None:
            # for 3-pin fan speed feedback
            self.multiplexer_port = self.device.i2c.get_port(
                self.device.PORT_GPIO_MULTIPLEXER_STIRRERS
            )


            # all GPIO pins output
            self.multiplexer_port.write_to(6, [0x00])
            # all GPIO pins output
            self.multiplexer_port.write_to(7, [0x00])
            # Initialize SPI port for fan monitoring
            self.fans_spi_port = self.device.spi.get_port(cs=4, freq=self.freq, mode=3)
            self.fans_spi_port.set_frequency(self.freq)

    def add_calibration_point(self, vial_number, speed, duty_cycle):
        assert speed in [0, 1, 2, 3]
        assert vial_number in [1, 2, 3, 4, 5, 6, 7]
        temp = self.device.calibration_fan_speed_to_duty_cycle
        temp[vial_number][speed] = duty_cycle
        self.device.calibration_fan_speed_to_duty_cycle = temp
        self.device.save()

    def _set_duty_cycle(self, vial, duty_cycle):
        assert 0 <= duty_cycle <= 1
        led_number = self.led_numbers[vial]
        self.pwm_controller.set_duty_cycle(led_number=led_number, duty_cycle=duty_cycle)

    def get_stirrer_duty_cycle(self, vial):
        led_number = self.led_numbers[vial]
        return self.pwm_controller.get_duty_cycle(led_number=led_number)

    def set_speed(self, vial, speed, accelerate=True):
        assert speed in ["stopped", "low", "high"]  # stopped, slow, fast
        self.check_calibration()
        if speed == "stopped":
            duty_cycle = 0
        else:
            duty_cycle = self.device.device_data["stirrers"]["calibration"][vial][speed]

        if 0 < duty_cycle < 0.5 and accelerate:
            accelerate_duty_cycle = self.device.device_data["stirrers"]["calibration"][vial]["high"] * 2
            accelerate_duty_cycle = min(accelerate_duty_cycle, 1)
            self._set_duty_cycle(vial, accelerate_duty_cycle)
            time.sleep(0.1)

        self._set_duty_cycle(vial=vial, duty_cycle=duty_cycle)

    def emergency_stop(self):
        for vial in range(1, 8):
            self._set_duty_cycle(vial, duty_cycle=0)

    def set_speed_all(self, speed, accelerate=True):
        assert speed in ["stopped", "low", "high"]
        for vial in range(1, 8):
            if speed == "stopped":
                duty_cycle = 0
            else:
                duty_cycle = self.device.device_data["stirrers"]["calibration"][vial][speed]
            if 0 < duty_cycle < 0.2 and accelerate:
                self._set_duty_cycle(vial=vial, duty_cycle=1)
                time.sleep(0.1)
            self._set_duty_cycle(vial, duty_cycle=duty_cycle)

    def check_calibration(self, vial=-1):
        if vial == -1:
            vials_list = [1, 2, 3, 4, 5, 6, 7]
        else:
            vials_list = [vial]
        for vial in vials_list:
            duty_cycle_slow = self.device.device_data["stirrers"]["calibration"][vial]["low"]
            duty_cycle_fast = self.device.device_data["stirrers"]["calibration"][vial]["high"]
            assert 0 <= duty_cycle_slow <= 1
            assert 0 <= duty_cycle_fast <= 1

    def _measure_rpm_no_lock(self, vial_number=7, estimated_rpm=None):
        if estimated_rpm is None:
            estimated_rpm = self.rpms[vial_number]
        if estimated_rpm is None:
            duty_cycle = self.get_stirrer_duty_cycle(vial_number)  # ftdi lock is checked here
            estimated_rpm = 2000 * duty_cycle
        if estimated_rpm < 10:
            return 0
        ms_per_rotation = 60 / estimated_rpm * 1000
        bits_per_minute = self.freq * 60
        ms_per_bit = 1 / self.freq * 1000
        bits_per_rotation = ms_per_rotation / ms_per_bit
        nbytes_per_rotation = bits_per_rotation / 8
        nbytes = int(nbytes_per_rotation * 0.8) + 16  # Safety factor to avoid overflow

        # Set up the multiplexer for the given vial
        # Read data from SPI port
        # get self.device.lock_ftdi lock
        ftdi_lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
        if not ftdi_lock_acquired:
            raise Exception("Could not acquire lock for reading stirrer speed at time %s" % time.ctime())
        try:
            self.multiplexer_port.write_to(7, [0x00])  # Output pin
            self.multiplexer_port.write_to(2, [vial_number - 1])
            t0 = time.time()

            res = self.fans_spi_port.read(nbytes)
        finally:
            self.device.lock_ftdi.release()
        dt = time.time() - t0
        binstr = "".join([bin(r)[2:].rjust(8, "0") for r in res])

        # Clean up the binary string
        binstr = binstr.replace("1110111", "1111111").replace("11100111", "11111111")

        # Calculate the ratio of '1's in the binary data
        ones_ratio = sum(1 for i in binstr if i == "1") / (8 * nbytes)

        # Find repeated sequences in the binary string
        periods = [len(match.group()) for match in re.finditer(r'(0+|1+)', binstr)]
        periods = periods[1:-1]  # cut first and last incomplete sequences

        # Check if any periods were found
        if len(periods) < 1:
            if estimated_rpm > 400:
                time.sleep(4)
                return self._measure_rpm_no_lock(vial_number, estimated_rpm / 2)
            else:
                return 0

        periods = np.array(periods)

        if len(periods) > 5:
            # remove outliers
            periods = periods[abs(periods - np.median(periods)) < 2 * np.std(periods)]

        if periods[0] > 1000:
            rpm = 60 * self.freq / periods[0] / 4
        else:
            rpm = 60 * self.freq / np.median(periods) / 4
        return rpm

    def measure_rpm(self, vial_number=7):
        # if file db/skip_stirrer_speed_measurement exists, return 0
        if os.path.exists("db/skip_stirrer_speed_measurement"):
            return 0
        rpm = self._measure_rpm_no_lock(vial_number)
        return rpm

    def measure_all_rpms(self, vials_to_measure=(1, 2, 3, 4, 5, 6, 7)):
        results = {vial_number: None for vial_number in range(1, 8)}
        for vial_number in vials_to_measure:
            results[vial_number] = self.measure_rpm(vial_number)
        for k,v in results.items():
            if v is not None:
                self.rpms[k] = v
        return results

    def get_calibration_curve(self, vial, n_points=10, time_sleep=2):
        min_duty_cycle = self.device.device_data["stirrers"]["calibration"][vial]["low"]
        max_duty_cycle = self.device.device_data["stirrers"]["calibration"][vial]["high"]
        rpm_dc = {}
        #accelerate to max duty cycle
        self._set_duty_cycle(vial, max_duty_cycle)
        time.sleep(3)
        # start measuring from max duty cycle to min duty cycle
        estimated_rpm = 3000
        duty_cycles_measured = np.linspace(min_duty_cycle, max_duty_cycle, n_points)[::-1]
        for i in range(len(duty_cycles_measured)):
            duty_cycle = duty_cycles_measured[i]
            if duty_cycle > 0:
                self._set_duty_cycle(vial, duty_cycle)
                time.sleep(time_sleep)
                rpm = self.measure_rpm(vial, estimated_rpm=estimated_rpm)
                rpm_dc[duty_cycle] = rpm
                estimated_rpm = rpm*duty_cycles_measured[i+1]/duty_cycles_measured[i] if i < len(duty_cycles_measured)-1 else rpm
        return rpm_dc

--- flask_app/minimal_device/test_hardware.py ---
import time


class Testing:
    def __init__(self, device):
        self.device = device
        self.stop_test = False

    def test_laser_signals(self):
        self.device.od_sesor.check()

    def stop(self):
        self.stop_test = True

    def check_stop(self):
        if self.stop_test:
            self.device.emergency_stop()
            raise RuntimeError("Test stopped")

    def background_visual_test_pump(self, main_gui=None, pump_number=1):
        def queued_function():
            try:
                main_gui.device_tab.testing_tab.pump_test_button.icon = "fa-spinner"
                main_gui.device_tab.testing_tab.pump_test_button.disabled = True
                self.visual_test_pump(pump_number=pump_number)
            finally:
                main_gui.device_tab.testing_tab.pump_test_button.icon = "fa-tint"
                main_gui.device_tab.testing_tab.pump_test_button.disabled = False

        self.device.dilution_worker.queue.put(queued_function)

    def visual_test_pump(self, pump_number=1, reverse=False):
        self.stop_test = False
        print("Starting fluid test: closing valves")
        self.check_stop()
        self.device.valves.close_all()
        self.check_stop()

        first_vial = 1
        if self.device.is_lagoon_device() and pump_number == 2:
            first_vial = 2

        self.device.valves.open(first_vial)
        self.check_stop()
        if reverse:
            exec("self.device.pump%d.move(-150)" % pump_number)
        else:
            exec("self.device.pump%d.move(150)" % pump_number)
        self.check_stop()
        print("pump %d pumping to vial 1" % pump_number)
        for i in range(6):
            time.sleep(0.5)
            self.check_stop()

        for v in range(first_vial, 7):
            self.check_stop()
            self.device.valves.open(v + 1)
            self.check_stop()
            print("pump %d pumping to vial %d and %d" % (pump_number, v, v + 1))
            self.device.valves.close(v)
            print("pump %d pumping to vial %d" % (pump_number, v + 1))
            self.check_stop()
            time.sleep(1)
            self.check_stop()
        exec("self.device.pump%d.stop()" % pump_number)
        # self.device.pump1.stop()
        self.check_stop()
        time.sleep(2)

        if not self.device.is_pumping():
            self.device.valves.close(7)
        else:
            print("valve 7 left open")
        print("FINISHED")
        print("test passed if no leakage was observed")


--- flask_app/minimal_device/thermometers.py ---
import os
import time

import pyftdi.i2c


class Thermometers:
    def __init__(self, device):
        self.device = device
        self.thermometer_vials = None
        self.thermometer_board = None

        if self.device.is_connected():
            self.connect()

    def connect(self):
        try:
            self.thermometer_vials = self.device.i2c.get_port(
                self.device.PORT_THERMOMETER_VIALS
            )
            self.thermometer_board = self.device.i2c.get_port(
                self.device.PORT_THERMOMETER_BOARD
            )
        except pyftdi.i2c.I2cNackError:
            print("PCA9685 PWM controller connection ERROR.")
        try:
            self.thermometer_vials.write([0x04])
            time.sleep(0.06)
            self.thermometer_vials.read_from(0x04, 2)
        except pyftdi.i2c.I2cNackError:
            self.thermometer_vials = self.device.i2c.get_port(
                self.device.PORT_THERMOMETER_VIALS_v4
            )

    # near DC-DC converters which get warm

    def measure_temperature_background_thread(self):
        if self.device.od_worker.queue.empty():
            self.device.od_worker.queue.put(self.measure_temperature)
        else:
            print("Temperature measurement not queued. OD thread queue is not empty.")

    def measure_temperature(self):
        temps = []
        for thermometer_port in [self.thermometer_vials, self.thermometer_board]:
            lock_acquired = self.device.lock_ftdi.acquire(timeout=15)
            if not lock_acquired:
                raise Exception("Could not acquire lock to measure temperature at time %s" % time.ctime())
            try:
                thermometer_port.write([0x04])
                time.sleep(0.06)
                data = thermometer_port.read_from(0x04, 2)
            finally:
                self.device.lock_ftdi.release()

            digital_temp = ((data[0] << 8) | data[1]) >> 4
            celsius_temp = digital_temp * 0.0625
            temps += [celsius_temp]
        t_vials, t_board = temps
        self.log_temperature(t_vials=t_vials, t_board=t_board)
        return t_vials, t_board

    def log_temperature(self, t_vials, t_board):
        """
        logs temperature if device.directory exists
        """
        if os.path.exists(str(self.device.directory)):
            filepath = os.path.join(self.device.directory, "temperature.csv")
            if not os.path.exists(filepath):
                with open(filepath, "w+") as f:
                    f.write("time,temperature_vials,temperature_board\n")
            with open(filepath, "a") as f:
                f.write("%d,%.3f,%.3f\n" % (time.time(), t_vials, t_board))


--- flask_app/minimal_device/valves.py ---
import time


class Valves:
    VALVE_OPEN_TIME = 1.5
    VALVE_CLOSE_TIME = 1.5
    DUTY_CYCLE_OPEN = 0.03
    DUTY_CYCLE_CLOSED = 0.12
    led_numbers = {valve: valve + 7 for valve in [1, 2, 3, 4, 5, 6, 7, 8]}

    def __init__(self, device):
        self.device = device
        self.pwm_controller = device.pwm_controller
        self.is_open = {1: None, 2: None, 3: None, 4: None, 5: None, 6: None, 7: None}

    def connect(self):
        self.sync_is_open_to_pwm()

    def sync_is_open_to_pwm(self):
        for v in range(1, 8):
            status = self.get_is_open(v)
            if status == 1:
                self.is_open[v] = True
            elif status == 0:
                self.is_open[v] = False
            else:
                self.is_open[v] = None

    def get_fully_open_valves(self):
        return [v for v in range(1, 8) if self.get_is_open(v) == 1]

    def get_fully_closed_valves(self):
        return [v for v in range(1, 8) if self.get_is_open(v) == 0]

    def get_is_open(self, valve_number):
        return self.get_percent_open_pwm(valve=valve_number)

    def all_closed(self):
        closed_valves = [self.device.device_data["valves"]["states"][i] == "closed" for i in range(1, 8)]
        return all(closed_valves)

    def not_all_closed(self):
        return not self.all_closed()

    def set_duty_cycle(self, valve, duty_cycle):
        """
        sets the duty cycle of the pwm signal for the valve.
        Stops pwm controller while changing value, to prevent the motor from
        moving after writing the first byte.
        """
        led_number = self.led_numbers[valve]
        if duty_cycle == self.DUTY_CYCLE_OPEN:
            timeout = 15
        else:
            timeout = 45
        lock_acquired = self.pwm_controller.lock.acquire(timeout=timeout)
        if not lock_acquired:
            raise Exception("Could not acquire lock to set duty cycle for valve %d at time %s" % (valve, time.ctime()))
        try:
            # self.pwm_controller.stop_all()
            self.pwm_controller.set_duty_cycle(
                led_number=led_number, duty_cycle=duty_cycle
            )
            # self.pwm_controller.start_all()
            time.sleep(0.04)
        finally:
            self.pwm_controller.lock.release()

    def open(self, valve):
        if valve not in self.get_fully_open_valves():
            self.set_duty_cycle(valve=valve, duty_cycle=self.DUTY_CYCLE_OPEN)
            time.sleep(self.VALVE_OPEN_TIME)
            self.is_open[valve] = True
            self.device.device_data["valves"]['states'][valve] = "open"
            self.device.eeprom.save_config_to_eeprom()

    def get_percent_open_pwm(self, valve):
        if self.pwm_controller.is_sleeping():
            return -1
        led_number = self.led_numbers[valve]
        duty_cycle = self.pwm_controller.get_duty_cycle(led_number=led_number)
        duty_cycle = round(duty_cycle, 3)
        op, cl = self.DUTY_CYCLE_OPEN, self.DUTY_CYCLE_CLOSED
        percent_closed = (duty_cycle - op) / (cl - op)
        percent_open = 1 - percent_closed
        return percent_open

    def close(self, valve, force=False):
        if self.is_open[valve] is not False:
            open_valves = [v for v in range(1, 8) if self.is_open[v]]
            remaining_open_valves = [v for v in open_valves if v != valve]
            if len(remaining_open_valves) < 1:
                assert (not self.device.is_pumping()), "can't close last valve while pumping"
            self.set_duty_cycle(valve=valve, duty_cycle=self.DUTY_CYCLE_CLOSED)
            time.sleep(self.VALVE_CLOSE_TIME)
            self.is_open[valve] = False
            self.device.device_data["valves"]['states'][valve] = "closed"
            self.device.eeprom.save_config_to_eeprom()

    def open_all(self):
        open_valves = self.get_fully_open_valves()
        for valve in range(1, 8):
            if valve not in open_valves:
                self.open(valve=valve)

    def close_all(self):
        assert not self.device.is_pumping(), "can't close last valve while pumping"
        closed_valves = self.get_fully_closed_valves()
        for valve in range(1, 8):
            if valve not in closed_valves:
                self.close(valve=valve)

    def close_all_except(self, valve):
        for v in range(1, 8):
            if v != valve and v not in self.get_fully_closed_valves():
                self.close(valve=v)

    def set_state(self, valve, is_open=False):
        assert is_open in [True, False]
        if is_open:
            self.open(valve)
        else:
            self.close(valve)


--- flask_app/minimal_device/workers.py ---
import logging
import os
import queue
import threading
import time


class ExperimentWorker:
    def __init__(self, experiment):
        self.experiment = experiment
        self.thread = None
        self.logger = logging.Logger(name="run_thread")
        log_filename = "main_run.log"
        log_filepath = os.path.join(experiment.directory, log_filename)
        self.handler = logging.FileHandler(log_filepath, "a", "utf-8")
        formatter = logging.Formatter(
            "%(asctime)s.%(msecs)03d %(levelname)s %(module)s - %(funcName)s: %(message)s",
            "%Y-%m-%d %H:%M:%S",
        )
        self.handler.setFormatter(formatter)
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(self.handler)
        self.keep_running = True

    def start(self):
        assert not self.is_alive(), "experiment already running"
        self.keep_running = True
        self.thread = threading.Thread(target=self._run_schedule, daemon=False)
        self.thread.start()

    def close(self):
        self.handler.close()

    def is_alive(self):
        if self.thread is None:
            return False
        else:
            return self.thread.is_alive()

    def status(self):
        if self.is_alive():
            print(time.ctime(), "Main thread: RUNNING")
        else:
            print(time.ctime(), "Main thread: NOT RUNNING")
        if self.experiment.device is not None:
            if (
                self.experiment.device.od_worker is not None
                and self.experiment.device.dilution_worker is not None
            ):
                self.experiment.device.od_worker.check_status()
                self.experiment.device.dilution_worker.check_status()
            else:
                print("Background thread workers not initialized.")
            for vial, lock in self.experiment.device.locks_vials.items():
                if lock.locked():
                    print("Vial %d: LOCKED" % vial)
            if self.experiment.device.lock_pumps.locked():
                print("Pumps: LOCKED")

    def stop(self):
        self.keep_running = False
        self.experiment.device.soft_stop_trigger = True
        while self.thread.is_alive():
            time.sleep(0.5)
        self.status()
        while (
            self.experiment.device.od_worker.is_performing_operation
            or self.experiment.device.dilution_worker.is_performing_operation
        ):
            self.status()
            time.sleep(5)
        print(time.ctime(), "main thread and workers safely STOPPED")
        self.experiment.device.soft_stop_trigger = False
        if self.thread._tstate_lock:
            self.thread._tstate_lock.release()
        self.thread._stop()

    def emergency_stop(self):
        self.experiment.device.emergency_stop()
        print("EMERGENCY STOP EXECUTED")
        self.stop()

    def _run_schedule(self):
        while self.keep_running:
            self.experiment.schedule.run_pending()
            time.sleep(1)


class QueueWorker:
    def __init__(self, device, worker_name):
        self.name = worker_name
        self.device = device
        self.logger = None
        self.queue = queue.Queue(maxsize=1)
        self.thread = threading.Thread(
            target=self.process_queue, args=[self.queue], daemon=False
        )
        if self.device.directory is not None:
            self.logger = logging.Logger(name=worker_name)
            log_filename = worker_name + "_thread.log"
            log_filepath = os.path.join(device.directory, log_filename)
            handler = logging.FileHandler(log_filepath, "a", "utf-8")
            formatter = logging.Formatter(
                "%(asctime)s %(created)f %(levelname)s %(module)s - %(funcName)s: %(message)s",
                "%Y-%m-%d %H:%M:%S",
            )
            handler.setFormatter(formatter)
            self.logger.setLevel(logging.DEBUG)
            self.logger.addHandler(handler)
            self.logger.info("Started Logger")
        self.is_performing_operation = False
        self.thread.start()
        print("%s worker started." % self.name)

    def stop(self):
        if self.thread._tstate_lock:
            self.thread._tstate_lock.release()
        self.thread._stop()

    def check_status(self):
        if not self.queue.empty():
            print("%s worker queue: NOT EMPTY" % self.name)
        if self.is_performing_operation:
            print(time.ctime(), "%s worker: WORKING" % self.name)
            # else:
            #     print("%s worker queue is empty." % self.name)
        else:
            print("%s worker: IDLE" % self.name)

    def process_queue(self, q):
        while True:
            try:
                queued_operation = q.get_nowait()
                try:
                    self.is_performing_operation = True
                    queued_operation()
                    self.is_performing_operation = False
                except Exception:
                    try:
                        self.logger.exception("**** Fatal ERROR in loop ****")
                        self.is_performing_operation = False
                    except Exception:  # if there is no logger file
                        pass

            except queue.Empty:
                time.sleep(0.5)

    #
    #     self.keep_running = True
    #     self.start()
    #
    # def start(self):
    #     self.keep_running = True
    #     self.thread = threading.Thread(target=self.process_queue,
    #                                    args=[self.queue], daemon=False)
    #     self.thread.start()
    #
    # def is_alive(self):
    #     if self.thread is None:
    #         return False
    #     else:
    #         return self.thread.is_alive()
    #
    #
    # def stop(self):
    #     self.keep_running = False
    #     while self.thread.is_alive():
    #         time.sleep(0.5)
    #     print("%s worker stopped safely." % self.name)


--- flask_app/notebook.py ---


#%%

--- flask_app/routes/__init__.py ---


--- flask_app/routes/device_routes.py ---
import threading
import traceback

from flask import Blueprint, request, jsonify, current_app
import time
import sys
sys.path.insert(0, '..')
from minimal_device.device_data import default_device_data
from minimal_device.base_device import BaseDevice
device_routes = Blueprint('device_routes', __name__)


@device_routes.route('/set-<string:devicePart>-state', methods=['POST'])
def set_device_state(devicePart):
    part_index = request.json['partIndex']
    new_state = request.json['newState']
    current_app.device.device_data[devicePart]['states'][part_index] = new_state
    if devicePart == 'valves':
        print(f'Toggled valve {part_index} to {new_state}')
        if new_state=='open':
            current_app.device.valves.open(part_index)
        elif new_state=='closed':
            current_app.device.valves.close(part_index)

    elif devicePart == 'pumps':
        print(f'Toggled pump {part_index} to {new_state}')
        # print(request.json)

        if new_state=='running':
            volume = None
            if 'volume' in request.json['input']:
                volume = float(request.json['input']['volume'])
                current_app.device.pumps[part_index].pump(volume)
            elif 'rotations' in request.json['input']:
                rotations = float(request.json['input']['rotations'])
                current_app.device.pumps[part_index].move(rotations)
            while current_app.device.pumps[part_index].is_pumping():
                time.sleep(0.2)
            if volume:
                adjust_stock_volume(pump_index=part_index, volume=volume)

        elif new_state=='stopped':
            if current_app.device.pumps[part_index].is_pumping():
                current_app.device.pumps[part_index].stop()
                print("Actively stopped pump", part_index)
        # volume = request.json['input']
        # current_app.device.pumps[part_index].pump(volume)

    elif devicePart == 'stirrers':
        time.sleep(0.01)
        # print(f'Toggled stirrer {part_index} to {new_state}')
        current_app.device.stirrers.set_speed(part_index, new_state)
    if devicePart == 'valves':
        current_app.device.eeprom.save_config_to_eeprom()
    return jsonify({'success': True, 'newState': new_state})


@device_routes.route('/stock_adjust?pump_index=<int:pump_index>?volume=<int:volume>', methods=['POST'])
def adjust_stock_volume(pump_index, volume):
    if pump_index == 1:
        stock_volume = "stock_volume_main"
    elif pump_index == 2:
        stock_volume = "stock_volume_drug"
    elif pump_index == 4:
        stock_volume = "stock_volume_waste"
    if hasattr(current_app, 'experiment'):
        parameters = current_app.experiment.parameters
        parameters[stock_volume] = float(parameters[stock_volume]) - volume
        current_app.experiment.parameters = parameters


@device_routes.route('/measure-<string:devicePart>', methods=['POST'])
def measure_device_part(devicePart):
    partIndex = int(request.json['partIndex'])
    if devicePart == 'ods':
        # print(f'Measuring OD {partIndex}')
        od, signal = current_app.device.od_sensors[partIndex].measure_od()
        # od_value = random.randint(0, 100)
        current_app.device.device_data[devicePart]['states'][partIndex] = od
        current_app.device.device_data[devicePart]['odsignals'][partIndex] = signal
    elif devicePart == 'thermometers':
        t_vials, t_board = current_app.device.thermometers.measure_temperature()
        current_app.device.device_data[devicePart]['states'] = {1: t_vials, 2: t_board}
    return jsonify({'success': True, 'device_states': current_app.device.device_data})

@device_routes.route('/get-stirrer-speeds', methods=['GET'])
def get_stirrer_speed():
    speeds = current_app.device.stirrers.measure_all_rpms()
    from flask import send_file
    import matplotlib.pyplot as plt
    from io import BytesIO

    plt.close()
    plt.bar(speeds.keys(), speeds.values())
    plt.ylim(0, max(max(speeds.values())*1.1, 5000))
    plt.ylabel('RPM')
    plt.xlabel('Vial')

    # Save the plot to a BytesIO object
    img = BytesIO()
    plt.savefig(img, format='png')
    img.seek(0)  # Rewind the buffer to the beginning
    plt.close()
    # Send the image as a response
    return send_file(img, mimetype='image/png',as_attachment=False)


@device_routes.route('/get-stirrer-calibration-curve/<int:vial_number>', defaults={'n_points': 10, 'time_sleep': 2}, methods=['GET'])
@device_routes.route('/get-stirrer-calibration-curve/<int:vial_number>/<int:n_points>/<int:time_sleep>', methods=['GET'])
def get_stirrer_calibration_curve(vial_number, n_points, time_sleep):
    from flask import send_file
    import matplotlib.pyplot as plt
    from io import BytesIO

    rpm_dc = current_app.device.stirrers.get_calibration_curve(vial_number, n_points, time_sleep)
    plt.clf()
    plt.plot(list(rpm_dc.keys()), list(rpm_dc.values()), "ro-")
    plt.title("Vial %d RPM vs Duty Cycle" % vial_number)
    plt.xlabel("Duty Cycle")
    plt.ylabel("RPM")
    # plt.ylim(0, 5000)
    plt.xlim(0, 1.05)
    img = BytesIO()
    plt.savefig(img, format='png')
    img.seek(0)  # Rewind the buffer to the beginning
    plt.close()
    # Send the image as a response
    return send_file(img, mimetype='image/png', as_attachment=False)


@device_routes.route('/get-all-device-data', methods=['GET'])
def get_all_device_states():
    print("Getting all device data")
    try:
        return jsonify({
        'success': True,
        'device_states': current_app.device.device_data,
    })
    except:
        return jsonify({
        'success': False,
        'error': 'Could not get device data',
    })


def fix_dict_keys_from_javascript(dict):
    new_dict = {}
    if dict is None:
        return None
    for key in dict:
        try:
            new_dict[float(key)] = dict[key]
        except:
            pass

    return new_dict


@device_routes.route('/set-<string:devicePart>-calibration', methods=['POST'])
def set_part_calibration(devicePart):
    data = request.get_json()
    partIndex = int(data.get('partIndex'))
    newCalibration = data.get('newCalibration')
    # implement logic to update the device part calibration based on `devicePart`, `partIndex`, and `newCalibration`
    # print(f'Set {devicePart} {partIndex} calibration to {newCalibration}')
    if devicePart == 'ods':
        newCalibration = fix_dict_keys_from_javascript(newCalibration)
    current_app.device.device_data[devicePart]['calibration'][partIndex] = newCalibration
    if devicePart == 'ods':
        current_app.device.od_sensors[partIndex].fit_calibration_function()
    if devicePart == 'stirrers':
        speed = current_app.device.device_data['stirrers']['states'][partIndex]
        current_app.device.stirrers.set_speed(partIndex, speed, accelerate=False)
        print("Calibrated and set stirrer speed to", speed)
        current_app.device.eeprom.save_config_to_eeprom()

    response = jsonify(success=True, newCalibration=newCalibration)
    if devicePart == 'ods':
        response = jsonify(success=True, newCalibration=newCalibration, coefs=current_app.device.device_data['ods']['calibration_coefs'][partIndex])
    return response


@device_routes.route('/measure-od-calibration', methods=['POST'])
def measure_od_calibration():
    data = request.get_json()
    odValue = data.get('odValue')
    odValue = float(odValue)
    print(f'Measuring OD calibration with OD {odValue}')
    for v in range(1,8):
        current_app.device.od_sensors[v].measure_od_calibration(odValue)
    for v in range(1,8):
        current_app.device.od_sensors[v].fit_calibration_function()
    current_app.device.eeprom.save_config_to_eeprom()
    return jsonify(success=True, odValue=odValue)


@device_routes.route('/start-pump-calibration-sequence', methods=['POST'])
def start_pump_calibration_sequence():
    data = request.get_json()
    print(data)
    pumpId = data.get('pumpId')
    rotations = data.get('rotations')
    iterations = data.get('iterations')
    print(f'Starting pump {pumpId} calibration sequence with {rotations} rotations and {iterations} iterations')

    if current_app.device.valves.all_closed():
        return jsonify(success=False, error="All valves are closed")
    current_app.device.device_data['pumps']['states'][pumpId] = 'running'
    for i in range(iterations):
        if current_app.device.device_data['pumps']['states'][pumpId] == 'stopped':
            break
        current_app.device.pumps[pumpId].move(rotations)
        while current_app.device.pumps[pumpId].is_pumping():
            time.sleep(0.1)
        time.sleep(0.5)
    return jsonify(success=True)


@device_routes.route('/force-connect-device', methods=['POST', 'GET'])
def force_connect_device():
    print("Force connecting device")
    try:
        if current_app.device.is_connected():
            current_app.device.disconnect_all()
            current_app.device.connect()
            current_app.device.hello()
            return jsonify({'success': True, 'device_states': current_app.device.device_data})
    except:
        print("Device not connected")
        pass
    try:
        print("Connecting device")
        current_app.device = BaseDevice(connect=True)
        if hasattr(current_app, "experiment"):
            current_app.experiment.device = current_app.device
        try:
            current_app.device.hello()
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        return jsonify({'success': True, 'device_states': current_app.device.device_data})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# route set led color for vials 1-7 in rgb values for a given vial
# rgb values are between 0 and 1
@device_routes.route('/set-led-color', methods=['POST'])
def set_led_color():
    data = request.get_json()
    vial = data.get('vial')
    red = data.get('red')
    green = data.get('green')
    blue = data.get('blue')
    current_app.device.rgb_leds.set_led(vial, red, green, blue)
    return jsonify({'success': True,
                    'device_states': current_app.device.device_data})

@device_routes.route('/reset-eeprom-memory', methods=['POST'])
def reset_eeprom_memory():
    current_app.device.eeprom.reset_memory()
    return jsonify({'success': True})

connection_lock = threading.Lock()

@device_routes.route('/connect-device', methods=['POST', 'GET'])
def connect_device():
    # check that another thread is not already connecting the device
    lock_available = connection_lock.acquire(timeout=1)
    if not lock_available:
        return jsonify({'success': False, 'error': 'Another thread is already connecting the device'})
    try:
        global dev
        try:
            if current_app.device.is_connected():
                print("Device already connected")
                if hasattr(current_app, "experiment"):
                    if current_app.experiment.device is not current_app.device:
                        print("Setting device for experiment")
                        current_app.experiment.device = current_app.device
                        current_app.experiment.device.hello()
                return jsonify({'success': True, 'device_states': current_app.device.device_data})
        except:
            print("Device not connected yet")
            pass
        try:
            print("Connecting device")
            current_app.device = BaseDevice(connect=True)
            current_app.device.hello()
            if hasattr(current_app, "experiment"):
                current_app.experiment.device = current_app.device
            return jsonify({'success': True, 'device_states': current_app.device.device_data})
        except:
            print("Connection error, printing traceback")
            traceback.print_exc()
            current_app.device = None
            if hasattr(current_app, "experiment"):
                current_app.experiment.device = current_app.device
            return jsonify({'success': False, 'error': 'Could not connect to the device'})
    finally:
        connection_lock.release()



--- flask_app/routes/experiment_routes.py ---
# experiment_routes.py
import sys

import pandas as pd
import sqlalchemy

sys.path.insert(0, "../")
from flask import Blueprint, request, jsonify, current_app, send_file
from experiment.database_models import ExperimentModel, CultureData, db, PumpData, CultureGenerationData
from experiment.experiment import Experiment
from routes.device_routes import connect_device

experiment_routes = Blueprint('experiment_routes', __name__)


@experiment_routes.route('/experiments', methods=['GET'])
def experiments():
    try:
        experiment_models = db.session.query(ExperimentModel).all()
    except sqlalchemy.exc.OperationalError:
        print("Database not initialized")
        return jsonify({'error': 'Database not initialized'}), 500
    experiments_clean = [{"id": 0, "name": "---- default template ----", "status": "stopped"}]
    for experiment_model in experiment_models:
        experiments_clean.append({'id': experiment_model.id, 'name': experiment_model.name, 'status': experiment_model.status})
    return jsonify(experiments_clean)


@experiment_routes.route('/experiments', methods=['POST'])
def create_experiment():
    experiment_data = request.json
    parameters = experiment_data.get('parameters', {})
    if parameters == {} or parameters is None:
        experiment_model = ExperimentModel(name=experiment_data['name'])
    else:
        experiment_model = ExperimentModel(name=experiment_data['name'], parameters=parameters)
    db.session.add(experiment_model)
    db.session.commit()
    return jsonify({'id': experiment_model.id, 'name': experiment_model.name}), 201


@experiment_routes.route('/experiments/<string:id>', methods=['GET'])
def get_experiment(id):
    # When id is 0, return default response
    if id == "0":
        return jsonify({'id': 0, 'name': '-----', 'status': 'stopped'})

    # When id is current, return current experiment
    if id == 'current':
        if not hasattr(current_app, 'experiment'):
            return jsonify({'id': None})
        else:
            return jsonify(current_app.experiment.model.to_dict()), 200

    # Check if id can be converted to an integer
    try:
        id = int(id)
    except ValueError:
        return jsonify({'error': 'Invalid experiment ID'}), 400

    # Fetch experiment from database
    experiment_model = db.session.get(ExperimentModel, id)

    # Return 404 if experiment not found
    if not experiment_model:
        return jsonify({'error': 'Experiment not found'}), 404

    # Create a new experiment if not already present
    if not hasattr(current_app, 'experiment'):
        if not hasattr(current_app, 'device'):
            connect_device()
        current_app.experiment = Experiment(current_app.device, experiment_model, db)

    # If current experiment is different from requested one
    if current_app.experiment.model.id != id:
        # If current experiment is running, stop it
        if current_app.experiment.model.status == 'running':
            current_app.experiment.stop()
            print("WARNING! Stopped existing running experiment", current_app.experiment.model.id)
        # Start the requested experiment
        current_app.experiment = Experiment(current_app.device, experiment_model, db)

    # Return the experiment data
    return jsonify(experiment_model.to_dict()), 200


@experiment_routes.route('/experiments/<int:id>/delete', methods=['GET'])
def delete_experiment(id):
    experiment_model = db.session.get(ExperimentModel, id)
    experiment_data = db.session.query(CultureData).filter(CultureData.experiment_id == id).all()
    pump_data = db.session.query(PumpData).filter(PumpData.experiment_id == id).all()
    culture_generation_data = db.session.query(CultureGenerationData).filter(CultureGenerationData.experiment_id == id).all()
    if experiment_model:
        db.session.delete(experiment_model)

        for culture_data in experiment_data:
            db.session.delete(culture_data)

        for pump_data in pump_data:
            db.session.delete(pump_data)

        for culture_generation_data in culture_generation_data:
            db.session.delete(culture_generation_data)

        db.session.commit()
        return jsonify({'message': 'Experiment deleted successfully'}), 200
    else:
        return jsonify({'error': 'Experiment not found'}), 404


@experiment_routes.route('/experiments/current/parameters', methods=['PUT'])
def update_experiment_parameters():
    new_parameters = request.json['parameters']
    if current_app.experiment.model.status == 'running':
        print("Not updating volume parameters of current experiment")
        for k in new_parameters.keys():
            if k not in ["cultures", "growth_parameters"]:
                new_parameters[k] = current_app.experiment.parameters[k]
    current_app.experiment.parameters = new_parameters

    for c in current_app.experiment.cultures.values():
        c.get_latest_data_from_db()
    return jsonify(current_app.experiment.model.to_dict()), 200


@experiment_routes.route('/experiments/current/growth_parameters', methods=['PUT'])
def update_experiment_growth_parameters():
    new_parameters = request.json['parameters']
    if current_app.experiment.model.status == 'running':
        print("Not updating volume parameters of current experiment")
        for k in new_parameters.keys():
            if k != 'cultures':
                new_parameters[k] = current_app.experiment.growth_parameters[k]
    current_app.experiment.growth_parameters = new_parameters
    # print("new_parameters", new_parameters)
    for c in current_app.experiment.cultures.values():
        c.get_latest_data_from_db()
    return jsonify(current_app.experiment.model.to_dict()), 200


@experiment_routes.route('/experiments/stop_all', methods=['GET'])
def stop_all_experiments():
    experiment_models = db.session.query(ExperimentModel).all()
    for experiment_model in experiment_models:
        if experiment_model.status == 'running':
            experiment_model.status = 'stopped'
            db.session.commit()
    return jsonify({'message': 'All experiments stopped'}), 200


@experiment_routes.route('/experiments/current/status', methods=['PUT'])
def update_experiment_status():
    status = request.json['status']
    if status == 'running':
        running_experiment = db.session.query(ExperimentModel).filter(ExperimentModel.status == 'running').first()
        if running_experiment:
            return jsonify({'error': 'Cannot start experiment, another experiment is already running'+str(running_experiment.__dict__)}), 400
        paused_experiment = db.session.query(ExperimentModel).filter(ExperimentModel.status == 'paused').first()
        if paused_experiment:
            if paused_experiment.id != current_app.experiment.model.id:
                return jsonify({'error': 'Cannot start experiment, another experiment is paused'+str(running_experiment.__dict__)}), 400

    if current_app.experiment:
        if status == 'stopped':
            current_app.experiment.stop()

        device = getattr(current_app, 'device', None)
        if device is None or not device.is_connected():
            try:
                connect_device()
            except Exception as e:
                return jsonify({'error': 'device not connected'}), 400

        if status == 'running':
            current_app.experiment.start()
        elif status == 'paused':
            current_app.experiment.pause_dilution_worker()
        return jsonify({'message': 'Experiment status update initialized'})
    else:
        return jsonify({'error': 'Experiment not found'}), 404


@experiment_routes.route('/status', methods=['GET'])
def get_status_dict():
    # not to be confused with running or stopped
    try:
        info = current_app.experiment.get_experiment_status_dict()
        return jsonify(info)
    except Exception as e:
        import traceback
        return traceback.format_exc()


@experiment_routes.route('/experiments/<int:experiment_id>/cultures/<int:id>', methods=['GET'])
def get_culture_data(experiment_id, id):
    culture = db.session.get(CultureData, id)
    if culture and culture.experiment_id == experiment_id:
        return jsonify(culture.to_dict())
    else:
        return jsonify({'error': 'Culture not found'}), 404


@experiment_routes.route('/plot/<int:vial>', methods=['GET'])
def get_culture_plot(vial):
    fig=current_app.experiment.cultures[vial].plot()
    fig_json = fig.to_json()
    return jsonify(fig_json)


@experiment_routes.route('/plot_simulation/<int:vial>', methods=['GET'])
def get_culture_predicted_plot(vial):
    try:
        fig = current_app.experiment.cultures[vial].plot_predicted()
        fig_json = fig.to_json()
        return jsonify(fig_json)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# @experiment_routes.route('/export/<int:vial>/excel', methods=['GET'])
# def export(vial):
#     culture = current_app.experiment.cultures[vial]
#     csv_path = culture.export_csv()
#     return send_file(csv_path, as_attachment=True)
#
#
# from flask import render_template_string

@experiment_routes.route('/export/<int:vial>/<string:filetype>', methods=['GET'])
def export(vial, filetype):
    culture = current_app.experiment.cultures[vial]
    if filetype == 'csv':
        csv_path = culture.export_csv()
        print(csv_path, "exported")

        return send_file(csv_path, as_attachment=True)
    elif filetype == 'html':
        html_path = culture.export_plot_html()  # Assuming that the plot() method returns a Plotly figure
        return send_file(html_path, as_attachment=True)
    else:
        return "Invalid filetype.", 400

--- flask_app/routes/service_routes.py ---
import os
import socket
import sys
import time

from flask import Blueprint, jsonify, send_file
import io

sys.path.insert(0, "../")


service_routes = Blueprint('service_routes', __name__)


@service_routes.route("/capture")
def capture_image():
    try:
        return capture_image_pi()
    except:
        try:
            return capture_image_picamzero()
        except:
            return capture_image_cv2()

@service_routes.route("/capture_picamzero")
def capture_image_picamzero():
    from picamzero import Camera
    stream = io.BytesIO()
    camera = Camera()
    camera.capture(stream, format='jpeg')
    camera.close()
    stream.seek(0)
    return send_file(stream, mimetype='image/jpeg', as_attachment=False)

@service_routes.route("/capture_cv2")
def capture_image_cv2():
    import cv2
    cap = cv2.VideoCapture(0)
    ret, frame = cap.read()
    cap.release()
    if not ret:
        return jsonify({"error": "Failed to capture image"}), 500

    _, img_encoded = cv2.imencode('.jpg', frame)
    stream = io.BytesIO(img_encoded.tostring())
    return send_file(stream, mimetype='image/jpeg', as_attachment=False)

@service_routes.route("/capturehires")
def capture_image_hq():
    from picamera import PiCamera
    stream = io.BytesIO()
    camera = PiCamera()
    camera.resolution = (2592, 1944)
    camera.start_preview()
    time.sleep(2)
    camera.capture(stream, format='jpeg')
    camera.stop_preview()

    stream.seek(0)
    camera.close()
    return send_file(stream, mimetype='image/jpeg', as_attachment=False)


@service_routes.route("/picapture")
def capture_image_pi():
    from picamera2 import Picamera2
    picam2 = Picamera2()
    try:
        config = picam2.create_still_configuration()
        picam2.configure(config)
        picam2.start()
        picam2.capture_file("img.jpg")
    finally:
        picam2.stop()
        picam2.close()
    return send_file("img.jpg", mimetype='image/jpeg', as_attachment=False)


from flask import abort

allowed_updates = {"frontend", "backend", "full"}

@service_routes.route('/update/<string:update_type>', methods=['GET'])
def update(update_type):
    if update_type not in allowed_updates:
        abort(400, 'Invalid update type. Must be one of: {}'.format(", ".join(allowed_updates)))

    script_path = os.path.dirname(__file__)
    makefile_dir = os.path.join(script_path, "../../")
    import subprocess
    update_log = os.path.join(script_path, "../../logs/update-{}.log".format(update_type))

    with open(update_log, "w+") as f:
        command = ["make", "-C", makefile_dir, "update-{}".format(update_type)]
        subprocess.Popen(command, stdout=f, stderr=subprocess.STDOUT, close_fds=True)

    return jsonify({'message': 'Software update initialized'})

@service_routes.route('/update_log', methods=['GET'])
def update_log():
    try:
        script_path = os.path.dirname(__file__)
        update_log = os.path.join(script_path, "../../logs/update.log")
        with open(update_log, "r") as f:
            log_content = f.read()
        return jsonify({'update_log': log_content})
    except FileNotFoundError:
        return jsonify({'error': 'Log file not found'}), 404


@service_routes.route('/hostname', methods=['GET'])
def get_hostname():
    hostname = socket.gethostname()
    return jsonify({'hostname': hostname})


@service_routes.route('/download_db', methods=['GET'])
def download_file():
    script_dir = os.path.dirname(__file__)
    rel_path = "../../db/replifactory.db"
    abs_file_path = os.path.join(script_dir, rel_path)
    return send_file(abs_file_path, as_attachment=True)

@service_routes.route('/download_flask_err', methods=['GET'])
def download_flask_err():
    script_dir = os.path.dirname(__file__)
    rel_path = "../../logs/flask-error.log"
    abs_file_path = os.path.join(script_dir, rel_path)
    return send_file(abs_file_path, as_attachment=True)

@service_routes.route('/download_flask_log', methods=['GET'])
def download_flask():
    script_dir = os.path.dirname(__file__)
    rel_path = "../../logs/flask.log"
    abs_file_path = os.path.join(script_dir, rel_path)
    return send_file(abs_file_path, as_attachment=True)


@service_routes.route('/log/<int:lines>/', methods=['GET'])
def get_log_tail(lines=100):
    script_path = os.path.dirname(__file__)
    log_flask_error = os.path.join(script_path, "../../logs/flask-error.log")
    log_flask = os.path.join(script_path, "../../logs/flask.log")
    log_express = os.path.join(script_path, "../../logs/express_server.log")
    log_express_error = os.path.join(script_path, "../../logs/express_server-error.log")
    import subprocess
    d={}
    for file in [log_flask_error, log_flask, log_express, log_express_error]:
        try:
            command = ["tail", "-n", str(lines), file]
            result = subprocess.run(command, stdout=subprocess.PIPE)
            if result.returncode == 0:
                d[file] = result.stdout.decode('utf-8')
        except:
            # windows
            command = ["powershell", "Get-Content", file, "-Tail", str(lines)]
            result = subprocess.run(command, stdout=subprocess.PIPE)
            if result.returncode == 0:
                d[file] = result.stdout.decode('utf-8')
            else:
                d[file] = "Error reading file"
    return jsonify(d)


# route to export csv of current experiment database
@service_routes.route('/export_csv', methods=['GET'])
def export_csv():
    return jsonify(current_app.experiment.model.to_dict()), 200

    # get all experiments from database
    experiments = db_session.query(Experiment).all()

    # create dataframe from experiments
    df = pd.DataFrame([exp.to_dict() for exp in experiments])

    # convert dataframe to csv
    csv = df.to_csv(index=False)

    # create response object
    response = Response(csv, mimetype='text/csv')
    response.headers['Content-Disposition'] = 'attachment; filename=export.csv'

    return response


@service_routes.route('/exec/<string:command>', methods=['GET'])
def execute_command(command):
    import subprocess
    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
        if result.returncode == 0:
            return jsonify({'output': result.stdout.decode('utf-8')}), 200
        else:
            return jsonify({'error running '+command: result.stdout.decode('utf-8')}), 500
    except:
        return jsonify({'error': 'Failed to execute command: '+command}), 500


@service_routes.route('/update_and_restart_experiment', methods=['PUT'])
def update_and_restart_experiment():
    import subprocess
    command = "make update_and_restart_experiment &"
    result = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if result.returncode == 0:
        return jsonify({'output': result.stdout.decode('utf-8')}), 200
    else:
        return jsonify({'error running '+command: result.stdout.decode('utf-8')}), 500
    return jsonify({'message': 'Update and restart initialized'})

--- flask_app/server.py ---
#server.py

import sys
import os
sys.path.append(os.path.dirname(os.path.realpath(__file__)))  # add dir to python path for flask-migrate

from waitress import serve
from flask import Flask, current_app
from routes.device_routes import device_routes, connect_device

from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
import logging
import os
import signal

from experiment.database_models import db
from routes.experiment_routes import experiment_routes
from routes.service_routes import service_routes

base_dir = os.path.dirname(os.path.abspath(__file__))
pid_file_path = os.path.join(base_dir, "data/flask_app.pid")


def create_app():
    pid = os.getpid()
    with open(pid_file_path, "w+") as pid_file:
        pid_file.write(str(pid))

    app = Flask(__name__)
    app.register_blueprint(device_routes)
    app.register_blueprint(experiment_routes)
    app.register_blueprint(service_routes)

    script_dir = os.path.dirname(os.path.abspath(__file__))
    db_path = os.path.join(script_dir, '../db/replifactory.db')
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'


    db.init_app(app)
    migrate = Migrate(app, db)

    with app.app_context():
        db.create_all()
        # connect_device()  # connect to device on startup
    CORS(app)

    @app.route('/shutdown')
    def shutdown():
        print("Shutting down server...")
        with open(pid_file_path, "r") as pid_file:
            pid = int(pid_file.read())
        try:
            current_app.device.disconnect_all()
        except:
            pass
        os.kill(pid, signal.SIGTERM)
    return app


def main():
    development = len(sys.argv) > 1 and sys.argv[1] == 'develop'

    app = create_app()
    with app.app_context():
        logging.info("Starting server...")
        if development:
            print("Running in development mode")
            app.run(debug=True, host="0.0.0.0", port=5000, use_reloader=True)
        else:
            print("Running in production mode, using waitress with 8 threads")
            serve(app, host="0.0.0.0", port=5000, threads=8)


if __name__ == '__main__':
    main()



--- flask_app/tests/__init__.py ---


--- flask_app/tests/debug/debug_device.py ---
import time

import pyftdi
from pyftdi.i2c import I2cController
from pyftdi.spi import SpiController
import sys
print(sys.path)
sys.path.append('./flask_app/')
from minimal_device.pwm import PwmController
class BaseDevice:
    PORT_ADC = 0x68  # MCP3421A0  1101 000
    # PORT_ADC = 0x69  # MCP3421A1  1101 001
    # PORT_ADC = 0x6a  # MCP3421A2  1101 010
    # PORT_ADC = 0x6b  # MCP3421A3  1101 011
    PORT_GPIO_MULTIPLEXER_LASERS = 0x20  # PCA 9555
    PORT_GPIO_MULTIPLEXER_ADC = 0x21  # PCA 9555
    PORT_GPIO_MULTIPLEXER_STIRRERS = 0x25  # PCA 9555
    PORT_THERMOMETER_VIALS = 0x49  # ADT 75  #0x4C?
    PORT_THERMOMETER_VIALS_v4 = 0x4C  # device version 4
    PORT_THERMOMETER_BOARD = 0x48  # ADT 75
    PORT_PWM = 0x70  # PCA9685
    PORT_EEPROM = 0x53

    def __init__(self, ftdi_address="ftdi://ftdi:2232h", connect=False, directory=None):
        t0 = time.time()
        print("Initializing device", time.ctime())
        self.ftdi_address = ftdi_address
        self.directory = directory

        self.active_pumps = (1, 2, 4)

        self.dilution_worker = None
        self.od_worker = None

        self.hard_stop_trigger = False
        self.soft_stop_trigger = False

        self.i2c = None
        self.spi = None

        self.pwm_controller = PwmController(device=self, frequency=50)
        # self.valves = Valves(device=self)
        # self.stirrers = Stirrers(device=self)
        # self.photodiodes = Photodiodes(device=self)
        # self.lasers = Lasers(device=self)
        # self.od_sensors = {v: OdSensor(device=self, vial_number=v) for v in range(1, 8)}
        # self.pump1 = Pump(device=self, cs=0)
        # self.pump2 = Pump(device=self, cs=1)
        # self.pump3 = Pump(device=self, cs=2)
        # self.pump4 = Pump(device=self, cs=3)
        # self.thermometers = Thermometers(device=self)
        # self.eeprom = EEPROM(device=self)
        # self.cultures = CultureDict(self)
    def connect(self, ftdi_address="ftdi://ftdi:2232h", retries=10):
        assert ftdi_address[-1] != "/", "ftdi_address should not end with a '/'"
        self.spi = SpiController(cs_count=5)
        self.spi.configure(ftdi_address + "/1")
        self.i2c = I2cController()
        self.i2c.configure(ftdi_address + "/2", frequency=1e4)
        self.pwm_controller.connect()

    def is_connected(self):
        return self.spi is not None and self.i2c is not None

if __name__ == "__main__":
    dev = BaseDevice()
    dev.connect()
    print("debug device connected - i2c and spi ok")

--- flask_app/tests/debug/erase_memory.py ---
import threading
import time

import pyftdi
from pyftdi.i2c import I2cController
from pyftdi.spi import SpiController
import sys
print(sys.path)
sys.path.append('./flask_app/')
from minimal_device.eeprom import EEPROM

class BaseDeviceEraseMemory:
    PORT_ADC = 0x68  # MCP3421A0  1101 000
    # PORT_ADC = 0x69  # MCP3421A1  1101 001
    # PORT_ADC = 0x6a  # MCP3421A2  1101 010
    # PORT_ADC = 0x6b  # MCP3421A3  1101 011
    PORT_GPIO_MULTIPLEXER_LASERS = 0x20  # PCA 9555
    PORT_GPIO_MULTIPLEXER_ADC = 0x21  # PCA 9555
    PORT_GPIO_MULTIPLEXER_STIRRERS = 0x25  # PCA 9555
    PORT_THERMOMETER_VIALS = 0x49  # ADT 75  #0x4C?
    PORT_THERMOMETER_VIALS_v4 = 0x4C  # device version 4
    PORT_THERMOMETER_BOARD = 0x48  # ADT 75
    PORT_PWM = 0x70  # PCA9685
    PORT_EEPROM = 0x53

    def __init__(self, ftdi_address="ftdi://ftdi:2232h", connect=False, directory=None):
        t0 = time.time()
        print("Initializing device", time.ctime())
        self.ftdi_address = ftdi_address
        self.directory = directory

        self.active_pumps = (1, 2, 4)

        self.dilution_worker = None
        self.od_worker = None

        self.hard_stop_trigger = False
        self.soft_stop_trigger = False
        self.lock_ftdi = threading.Lock()

        self.i2c = None
        self.spi = None

        # self.pwm_controller = PwmController(device=self, frequency=50)
        # self.valves = Valves(device=self)
        # self.stirrers = Stirrers(device=self)
        # self.photodiodes = Photodiodes(device=self)
        # self.lasers = Lasers(device=self)
        # self.od_sensors = {v: OdSensor(device=self, vial_number=v) for v in range(1, 8)}
        # self.pump1 = Pump(device=self, cs=0)
        # self.pump2 = Pump(device=self, cs=1)
        # self.pump3 = Pump(device=self, cs=2)
        # self.pump4 = Pump(device=self, cs=3)
        # self.thermometers = Thermometers(device=self)
        # self.cultures = CultureDict(self)
        self.eeprom = EEPROM(self)

    def connect(self, ftdi_address="ftdi://ftdi:2232h", retries=10):
        assert ftdi_address[-1] != "/", "ftdi_address should not end with a '/'"
        self.spi = SpiController(cs_count=5)
        self.spi.configure(ftdi_address + "/1")
        self.i2c = I2cController()
        self.i2c.configure(ftdi_address + "/2", frequency=1e4)
        # self.pwm_controller.connect()

    def is_connected(self):
        return self.spi is not None and self.i2c is not None


if __name__ == "__main__":
    dev = BaseDeviceEraseMemory()
    dev.connect()
    dev.eeprom.connect_without_load()

    # user input to confirm
    print("Are you sure you want to erase the memory? (yes/no)")
    user_input = input()
    if user_input == "yes":
        dev.eeprom.erase_memory()
        print("Memory erased.")
    else:
        print("Memory not erased.")
    print("debug device connected - i2c and spi ok")

--- flask_app/tests/device_test.py ---
#%%
import sys
sys.path.append('./flask_app/')
from minimal_device.base_device import BaseDevice
import time

dev = BaseDevice()
dev.connect()
dev.hello()
dev.stirrers._set_duty_cycle(1, 0.6)
time.sleep(3)

rpm=dev.stirrers.measure_rpm(1)
print(rpm)
quit()

--- flask_app/tests/experiment_test.py ---
from experiment.experiment import Experiment
import time
from flask import Flask

from minimal_device.base_device import BaseDevice
dev = BaseDevice()
# dev.connect()
# dev.hello()
from experiment.database_models import ExperimentModel, db
import os

def create_test_app():
    app = Flask(__name__)

    script_dir = os.path.dirname(os.getcwd())
    db_path = os.path.join(script_dir, 'replifactory_v7/db/replifactory.db')
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

    db.init_app(app)
    with app.app_context():
        db.create_all()
    return app

# Create test app and keep the context for further use
app = create_test_app()
ctx = app.app_context()
ctx.push()  # This enters the application context

experiment_model = db.session.get(ExperimentModel, 2)
print(experiment_model)
app.experiment = Experiment(dev, experiment_model, db)
#%%
app.experiment.device.hello()
#%%
experiment.cultures[6].update()
#%%
experiment.cultures[7].update()
#%%
experiment.cultures[7].get_first_od_timestamp()
#%%
experiment.start()
#%%
experiment.stop()
#%%
experiment.pause_dilution_worker()
#%%
#%%
experiment_model = db.session.get(ExperimentModel, 2)
experiment = Experiment(dev, experiment_model)


#%%
#%%
#%%

#%%
experiment.locks[1].locked()
# experiment.attempt_dilute_in_background(vial_number=7, main_pump_volume=0, drug_pump_volume=0)
# experiment_worker.start()
#%%
# experiment.attempt_dilute_in_background(vial_number=7, main_pump_volume=0, drug_pump_volume=0)
print("las")
#%%
# experiment.attempt_dilute_in_background(vial_number=7, main_pump_volume=0, drug_pump_volume=0)
# experiment.measure_od_in_background()

#%%
for v in range(1,8):
    dev.stirrers.set_speed(v, "stopped")
#%%
from minimal_device.od_sensor import measure_od_all
print(measure_od_all(device=dev))

#%%
experiment_worker.pause()
#%%
experiment_worker.stop()
#%%
# Keep the experiment worker running for a while
time.sleep(10)

# Pause the experiment worker
experiment_worker.pause()
time.sleep(5)

# Resume the experiment worker
experiment_worker.resume()
time.sleep(5)

# Stop the experiment worker
experiment_worker.stop()


--- flask_app/tests/old_tests/culture_test.py ---
from datetime import datetime, timedelta

from experiment.experiment import Experiment
import time

from flask import Flask

from minimal_device.base_device import BaseDevice

dev = None

dev = BaseDevice()
dev.connect()

from experiment.database_models import ExperimentModel, db
import os

from flask_app.server import create_app
app = create_app()
ctx = app.app_context()
ctx.push()

def create_test_app():
    app = Flask(__name__)

    script_dir = os.path.dirname(__file__)
    print(os.path.abspath(script_dir),"script_dir")
    db_path = os.path.join(os.path.abspath(script_dir), './db/replifactory.db')
    print(os.path.abspath(db_path),"db_path")
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

    db.init_app(app)
    with app.app_context():
        db.create_all()
    return app

experiment_model = db.session.get(ExperimentModel, 5)
if experiment_model is None:
    experiment_model = ExperimentModel(name="test_experiment")
    db.session.add(experiment_model)
    db.session.commit()
experiment = Experiment(dev, experiment_model, db)
c = experiment.cultures[2]
#%%
# print(c.is_time_to_dilute())

# c.increase_stress()
#%%
#%%

#%%
# c.get_latest_data_from_db()
print(c.parameters)
#%%
with experiment.app.app_context():
    print(db.session.get(ExperimentModel, c.experiment.model.id).parameters)
#%%

# experiment.start()
#%%
# experiment.stop()
#%%
print([experiment.cultures[v].drug_concentration for v in range(1,8)])
#%%
db.session.commit()
#%%
#%%

#%%
# experiment.start()
#%%
# experiment._delete_all_data()
for c in experiment.cultures.values():
    c.parameters["volume_added"] = 0.2
#%%
# experiment.stop()
#%%
from pprint import pprint
pprint(c.parameters.__dict__)
pprint(str(c.experiment.get_status()).replace("'", '').replace('"', ''))

#%%
with app.app_context():
    c.get_latest_data_from_db()
    print(c.parameters)
    print(c.parameters)
    c.update()
pprint(c.__dict__)
pprint(c.get_status())
[c.experiment.device.stirrers.set_speed(v,"stopped") for v in range(1, 8)]

c.update()

--- flask_app/tests/old_tests/culture_tests.py ---
# tests.py
import datetime
import random
import sys
import time
import unittest
import json
from pprint import pprint
sys.path.insert(0, "..")
sys.path.insert(0, "../experiment")

from flask_app.server import create_app, db


class RoutesTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app()
        # self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # Use in-memory SQLite database for testing
        # self.app.config['TESTING'] = True
        self.client = self.app.test_client()
        with self.app.app_context():
            db.create_all()

    def tearDown(self):
        with self.app.app_context():
            # db.session.remove()
            # db.drop_all()
            db.session.commit()

    def test_get_current_experiment(self):
        response1 = self.client.get(f'/experiments/1')
        self.assertEqual(response1.status_code, 200)
        response = self.client.get(f'/experiments/current').get_json()
        self.assertEqual(response["id"], 1)

    def test_culture(self):
        response1 = self.client.get(f'/experiments/6')
        c=self.app.experiment.cultures[3]
        with self.app.app_context():
            c.get_latest_data_from_db()
            # "2023-06-11 06:36:38.958148"
            # parse
            # timepoint = datetime.datetime.strptime("2023-06-12 0:38:38.958148", "%Y-%m-%d %H:%M:%S.%f")
            # c.get_data_at_timepoint(timepoint)
        pprint(c.__dict__)
        c.calculate_pump_volumes(3,1.6, 12)

    def test_new_update(self):
        from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater
        from experiment.ModelBasedCulture.real_culture_wrapper import RealCultureWrapper

        updater = MorbidostatUpdater(
            od_dilution_threshold=0.3,  # OD at which dilution occurs
            dilution_factor=1.5,  # Factor by which the population is reduced during dilution
            dilution_number_initial_dose=1,  # Number of dilutions before adding the drug
            dose_initial_added=6.2,  # Initial dose added to the culture
            dose_increase_factor=1.3,  # Factor by which the dose is increased at stress increases after the initial one
            threshold_growth_rate_increase_stress=0.15,  # Min growth rate threshold for stress increase
            threshold_growth_rate_decrease_stress=0.005,  # Max growth rate threshold for stress decrease
            delay_dilution_max_hours=6,  # Maximum time between dilutions
            delay_stress_increase_min_generations=3,  # Minimum generations between stress increases
            volume_vial=12,  # Volume of the vial
            pump1_stock_drug_concentration=0,  # Concentration of the drug in the pump 1 stock
            pump2_stock_drug_concentration=300)

        response1 = self.client.get(f'/experiments/8')
        print(response1.get_json())
        culture=self.app.experiment.cultures[3]
        print(culture.__dict__)
        with self.app.app_context():
            culture.get_latest_data_from_db()
            adapted_culture = RealCultureWrapper(culture)
            for i in range(3):
                updater.update(adapted_culture)
        pprint(culture.__dict__)

    def test_plot_model(self):
        response1 = self.client.get(f'/experiments/11')
        print(response1.get_json())
        culture=self.app.experiment.cultures[3]
        print(culture.__dict__)
        with self.app.app_context():
            culture.get_latest_data_from_db()
        fig=culture.plot_predicted()
        import plotly.io as pio
        pio.show(fig)
if __name__ == '__main__':
    unittest.main()


--- flask_app/tests/old_tests/culture_update_test.py ---
from datetime import datetime, timedelta

import numpy as np

from experiment.experiment import Experiment
from experiment.database_models import ExperimentModel, db
from flask_app.server import create_app
app = create_app()
ctx = app.app_context()
ctx.push()

experiment_model = db.session.get(ExperimentModel, 1)
dev = None
if hasattr(ctx.app, 'dev'):
    dev = ctx.app.dev
exp = Experiment(dev, experiment_model, db)
c = exp.cultures[1]
#%%
c = exp.cultures[2]
c.get_latest_data_from_db()
def test_is_time_to_rescue():
    # Test case 1: last_dilution_time is None
    c.last_dilution_time = None
    assert not c.is_time_to_rescue(verbose=True), "Expected False when last_dilution_time is None"

    # Test case 2: growth_rate is None
    c.last_dilution_time = datetime.now()
    c.growth_rate = None
    assert not c.is_time_to_rescue(verbose=True), "Expected False when growth_rate is None"

    # Test case 3: last_dilution_time is too recent
    c.last_dilution_time = datetime.now() - timedelta(hours=1)
    c.growth_rate = 0.1
    c.parameters["stress_decrease_delay_hrs"] = 99
    assert not c.is_time_to_rescue(verbose=True), "Expected False when last dilution is too recent"

    # Test case 4: latest_t_doubling is positive and below threshold
    c.last_dilution_time = datetime.now() - timedelta(hours=100)
    c.growth_rate = 0.1
    c.parameters["stress_decrease_delay_hrs"] = 99
    c.parameters["stress_decrease_tdoubling_min_hrs"] = 10
    assert not c.is_time_to_rescue(verbose=True), "Expected False when latest_t_doubling is positive and below threshold"

    # Test case 5: latest_t_doubling is negative or above threshold
    c.last_dilution_time = datetime.now() - timedelta(hours=100)
    c.growth_rate = 0.1
    c.parameters["stress_decrease_delay_hrs"] = 99
    c.parameters["stress_decrease_tdoubling_min_hrs"] = 5
    assert c.is_time_to_rescue(verbose=True), "Expected True when latest_t_doubling is negative or above threshold"

    print("All tests passed!")
# test_is_time_to_rescue()
#%%
def test_is_time_to_increase_stress():
    # Test Case 1: last_dilution_time is None
    c.last_dilution_time = None
    c.growth_rate = 0.1
    c.last_stress_increase_generation = 2
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 2: growth_rate is None
    c.last_dilution_time = datetime.now() - timedelta(hours=1)
    c.growth_rate = None
    c.last_stress_increase_generation = 2
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 3: last_stress_increase_generation is None
    c.last_dilution_time = datetime.now() - timedelta(hours=1)
    c.growth_rate = 0.1
    c.last_stress_increase_generation = None
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 4: generation is not greater than stress_increase_delay_generations
    c.generation = 1
    c.parameters["stress_increase_delay_generations"] = 2
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 5: growth_rate is not positive
    c.generation = 3
    c.growth_rate = -0.1
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 6: generation - last_stress_increase_generation is not greater than stress_increase_delay_generations
    c.growth_rate = 0.1
    c.last_stress_increase_generation = 1
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 7: latest_t_doubling is not above threshold
    c.last_stress_increase_generation = 0
    c.growth_rate = np.log(2) / c.parameters["stress_increase_tdoubling_max_hrs"]
    assert not c.is_time_to_increase_stress(verbose=True)

    # Test Case 8: all conditions met
    c.growth_rate = np.log(2) / (c.parameters["stress_increase_tdoubling_max_hrs"] - 1)
    assert c.is_time_to_increase_stress(verbose=True)

    print("All tests passed!")
# test_is_time_to_increase_stress()
#%%
# c.generation
for v in range(1,8):
    c = exp.cultures[v]
#%%
def object_to_dict(obj):
    if not hasattr(obj, "__dict__"):
        return repr(obj)
    result = {}

    for key, value in obj.__dict__.items():
        if isinstance(value, dict):
            # if the value is a dictionary, we represent it as a multi-line string
            value = '\n'.join([f'{k}: {v}' for k, v in value.items()])
        else:
            value = repr(value)  # Otherwise, we use repr to get a string representation of the attribute value
        result[key] = value
    return result


from pprint import pprint, pformat
pprint(object_to_dict(c.experiment))
#%%
exp.model.parameters["cultures"]["1"]["description"] = "lalala"
db.session.commit()
#%%
exp.model.parameters
#%%
db.session.get(ExperimentModel, id)


--- flask_app/tests/old_tests/db _update_test.py ---
from datetime import datetime, timedelta

import numpy as np

from experiment.experiment import Experiment
from experiment.database_models import ExperimentModel, db
from flask_app.server import create_app
app = create_app()
ctx = app.app_context()
ctx.push()

experiment_model = db.session.get(ExperimentModel, 1)
dev = None
if hasattr(ctx.app, 'dev'):
    dev = ctx.app.dev
exp = Experiment(dev, experiment_model, db)
c = exp.cultures[1]
#%%
experiment_model.parameters["cultures"]["1"]["name"] = "test"
experiment_model.parameters

db.session.commit()

experiment_model.parameters

#%%
from copy import deepcopy
params = deepcopy(experiment_model.parameters)

# Update the field
params["cultures"]["1"]["name"] = "test"

# Assign the updated parameters back to the model
experiment_model.parameters = params
# Commit the session
db.session.commit()
#%%
experiment_model.parameters


--- flask_app/tests/old_tests/device_test.py ---
#%%
import os
import sys
sys.path.append('./flask_app/')
import importlib
import minimal_device
from minimal_device.base_device import BaseDevice

importlib.reload(minimal_device)
dev = BaseDevice()
dev.connect()
# dev.hello()
#%%
[dev.stirrers._set_duty_cycle(v, 0) for v in range(1,8)]
speeds = dev.stirrers.measure_all_rpms()
#%%
import numpy as np
import re
import time
import matplotlib.pyplot as plt
speeds={1:0.4,
 2:0.4,
 3:0.49,
 4:0.46,
 5:0.39,
 6:0.38,
 7:0.4}
[dev.stirrers._set_duty_cycle(v, speeds[v]) for v in range(1,8)]
#%%
#%%
dev.stirrers._set_duty_cycle(7, 0.4)
import time
import re
import numpy as np
import matplotlib.pyplot as plt
#%%
rpm=3000
for i in range(8):
    rpm=dev.stirrers.measure_rpm(7, estimated_rpm=1000)
    print(rpm)
    time.sleep(0.5)
#%%
dev.device_data["stirrers"]["calibration"][vial_number]={'high': 1, 'low': 0.1}

#%%
vial_number=7
rpm_dc={}
dev.stirrers.get_calibration_curve(vial_number, n_points=5)
#%%
plt.plot(list(rpm_dc.keys()),list(rpm_dc.values()),"ro-")
plt.title("Vial %d RPM vs Duty Cycle"%vial_number)
plt.xlabel("Duty Cycle")
plt.ylabel("RPM")
plt.show()
#%%
results = []
estimated_rpm = 1000
for _ in range(9):
    results += [dev.stirrers.measure_rpm(vial_number, estimated_rpm=estimated_rpm)]
    estimated_rpm = results[-1]
    plt.plot(results)
    plt.axhline(np.mean(results) - 2*np.std(results), color='r', linestyle='--')
    plt.axhline(np.mean(results) + 2*np.std(results), color='r', linestyle='--')
    plt.show()
    time.sleep(2)
#%%
print(dev.device_data['valves']['states'][1])
#%%
vial=1
minimal_device.od_sensor.OdSensor.fit_calibration_function(dev.od_sensors[vial])
print(dev.device_data['ods']['calibration'][vial])
dev.od_sensors[vial].mv_to_od(10)
dev.od_sensors[vial].plot_calibration_curve()
#%%
#%%
dev.eeprom.read_config_from_device()
#%%
from minimal_device.device_data import default_device_data
print(default_device_data)
dev.device_data = default_device_data
import time
t=time.time()
dev.eeprom.save_config_to_eeprom()
print(dev.device_data)
print(time.time()-t)

dev.stirrers.set_speed(7, "high")
dev.stirrers.get_stirrer_duty_cycle(1)
time.sleep(2)
dev.stirrers.set_speed(1, "stopped")
dev.stirrers.get_stirrer_duty_cycle(1)
dev.stirrers.set_speed(1, "stopped")
dev.stirrers.get_stirrer_duty_cycle(1)
#%%
dev.disconnect_all()
#%%


--- flask_app/tests/old_tests/experiment_routes_tests.py ---
# tests.py
import random
import sys
import time
import unittest
import json

sys.path.insert(0, "..")
sys.path.insert(0, "../experiment")

from flask_app.server import create_app, db


class RoutesTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app()
        # self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # Use in-memory SQLite database for testing
        # self.app.config['TESTING'] = True
        self.client = self.app.test_client()
        with self.app.app_context():
            db.create_all()

    def tearDown(self):
        with self.app.app_context():
            # db.session.remove()
            # db.drop_all()
            db.session.commit()

    def test_create_experiment(self):
        name = 'Exp'+str(time.ctime())
        data = {
            'name': name,
            'parameters': {'stock_volume_main': 2000, 'stock_volume_drug': 1000, 'stock_volume_waste': 5000,}
        }
        response = self.client.post('/experiments', data=json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        response = self.client.get('/experiments').get_json()
        assert name in [exp["name"] for exp in response]

    def test_get_experiment(self):
        response = self.client.get(f'/experiments/1')
        self.assertEqual(response.status_code, 200)

    def test_get_current_experiment(self):
        response1 = self.client.get(f'/experiments/1')
        self.assertEqual(response1.status_code, 200)
        response = self.client.get(f'/experiments/current').get_json()
        self.assertEqual(response["id"], 1)

    def test_direct_update(self):
        with self.app.app_context():
            response = self.client.get(f'/experiments/1')
            parameters = self.app.experiment.parameters
            rand = random.randint(10, 50)/100
            parameters['cultures']["1"]['od_threshold'] = rand
            self.app.experiment.parameters = parameters
            assert self.app.experiment.parameters['cultures']["1"]['od_threshold'] == rand
            assert self.app.experiment.model.parameters['cultures']["1"]['od_threshold'] == rand
            exp = self.client.get(f'/experiments/1').get_json()
            print(rand, exp)
            assert exp['parameters']['cultures']["1"]['od_threshold'] == rand

    def test_update_experiment_parameters(self):
        with self.app.app_context():
            # First, create an experiment
            response = self.client.get(f'/experiments/8')
            self.assertEqual(response.status_code, 200)
            id = response.get_json()["id"]
            parameters = response.get_json()["parameters"]

            rand = random.randint(10, 50)/100
            parameters['cultures']["1"]['od_threshold'] = rand


            response = self.client.put(f'/experiments/current/parameters', data=json.dumps({'parameters': parameters}), content_type='application/json')
            self.assertEqual(response.status_code, 200)
            response = self.client.get(f'/experiments/current')
            parameters = response.get_json()["parameters"]
            self.assertEqual(rand, parameters['cultures']["1"]['od_threshold'])
            # self.app.experiment.cultures[1].get_latest_data_from_db()
            self.assertEqual(rand, self.app.experiment.cultures[1].parameters['od_threshold'])
            self.assertEqual(rand, self.app.experiment.parameters["cultures"]["1"]['od_threshold'])

    def test_start_stop(self):
        response = self.client.get(f'/experiments/1')
        response = self.client.put(f'/experiments/current/status', data=json.dumps({'status': 'running'}),
                                   content_type='application/json')
        self.assertEqual(response.status_code, 200)
        response = self.client.get(f'/experiments/current')
        self.assertEqual(response.get_json()["status"], 'running')
        self.client.put(f'/experiments/current/status', data=json.dumps({'status': 'stopped'}),
                        content_type='application/json')

    def test_update_experiment_parameters2(self):
        with self.app.app_context():
            self.client.get(f'/experiments/1')

            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug before")
            parameters = self.app.experiment.parameters
            parameters["stock_volume_drug"] = stv - 10
            self.app.experiment.parameters = parameters
            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug after")

            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug before")
            parameters = self.app.experiment.parameters
            parameters["stock_volume_drug"] = stv - 10
            self.app.experiment.parameters = parameters
            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug after")

            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug before")
            parameters = self.app.experiment.parameters
            parameters["stock_volume_drug"] = stv - 10
            self.app.experiment.parameters = parameters
            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug after")

        def test_update_experiment_parameters3(self):
            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug before")
            parameters = self.app.experiment.parameters
            parameters["stock_volume_drug"] = stv - 10
            self.app.experiment.parameters = parameters
            response = self.client.get(f'/experiments/current')
            stv = response.get_json()["parameters"]["stock_volume_drug"]
            print(stv, "stock_volume_drug after")

if __name__ == '__main__':
    unittest.main()


--- flask_app/tests/old_tests/plot_test.py ---
import time
from datetime import datetime, timedelta

import experiment.plot
from experiment.experiment import Experiment

dev = None

from experiment.database_models import ExperimentModel, db
import os

from flask_app.server import create_app
app = create_app()
ctx = app.app_context()
ctx.push()

experiment_model = db.session.get(ExperimentModel, 2)
exp = Experiment(dev, experiment_model, db)
c = exp.cultures[2]
#%%
import pandas as pd
df=pd.read_csv(r"C:\Users\crusnac\Dropbox\IST\replifactory_v5\data\Cobalt_300922\vial_1\od.csv")
dosedf=pd.read_csv(r"C:\Users\crusnac\Dropbox\IST\replifactory_v5\data\Cobalt_300922\vial_1\medium2_concentration.csv")
gendf = pd.read_csv(r"C:\Users\crusnac\Dropbox\IST\replifactory_v5\data\Cobalt_300922\vial_1\log2_dilution_coefficient.csv")
print(df.od[0])
#%%
# c._delete_all_records()
t0=time.time()
for i in range(df.shape[0]):
    t = datetime.fromtimestamp(df.time[i])
    od = df.od[i]
    c._log_testing_od(od, timestamp=t)
    if i%10==0:
        print(i,time.time()-t0,end="\r")
# ods=c.get_last_ods()
# print(ods)
#%%
for i in range(dosedf.shape[0]):
    t = datetime.fromtimestamp(gendf.time[i])
    c._log_testing_generation(generation=gendf.log2_dilution_coefficient[i],
                              concentration=dosedf.medium2_concentration[i],
                              timestamp=t)
#%%

import experiment.plot
import importlib
#%%
importlib.reload(experiment)
importlib.reload(experiment.plot)
from experiment.plot import plot_culture

t0=time.time()
plot_culture(c).show()
# print(plot_culture(c).to_json())
# print(time.time()-t0)
#%%
culture = c
limit = 100
gens, concs = culture.get_last_generations(limit=limit)
print(gens)

# c.calculate_generation_concentration_after_dil(1,9)
#%%
c.is_time_to_dilute()
#%%
from pprint import pprint
pprint(c.__dict__)


--- flask_app/tests/old_tests/service_routes_tests.py ---
# tests.py
import datetime
import random
import sys
import time
import unittest
import json

sys.path.insert(0, "..")
sys.path.insert(0, "../experiment")

from flask_app.server import create_app, db


class RoutesTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app()
        # self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # Use in-memory SQLite database for testing
        # self.app.config['TESTING'] = True
        self.client = self.app.test_client()
        with self.app.app_context():
            db.create_all()

    def tearDown(self):
        with self.app.app_context():
            # db.session.remove()
            # db.drop_all()
            db.session.commit()

    def test_capture(self):
        response1 = self.client.get(f'/capture')
        print(response1.get_json())

    def test_update(self):
        response1 = self.client.get(f'/update_software')
        print(response1.get_json())

    def test_update_log(self):
        response1 = self.client.get(f'/update_log')
        print(response1.get_json())

if __name__ == '__main__':
    unittest.main()


--- flask_app/tests/old_tests/tests.py ---
# tests.py
import sys

sys.path.insert(0, "..")
sys.path.insert(0, "../experiment")
import unittest
from flask_app.experiment.database_models import ExperimentModel, Culture
from flask_app.server import create_app, db


class ModelTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app()
        self.client = self.app.test_client()
        # self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
        # self.app.config['TESTING'] = True
        with self.app.app_context():
            db.create_all()
            print(self.app.config['SQLALCHEMY_DATABASE_URI'])

    def tearDown(self):
        with self.app.app_context():
            # db.session.remove()
            # db.drop_all()
            db.session.commit()
            pass

    def create_model(self, model, **kwargs):
        with self.app.app_context():
            instance = model(**kwargs)
            db.session.add(instance)
            db.session.commit()
            return instance.id

    def test_create_experiment(self):
        experiment_id = self.create_model(ExperimentModel, name="Exp22",
                                          parameters={'stock1_volume': 2000, 'stock2_volume': 1000})

        # Query for the Experiment instance in the database
        with self.app.app_context():
            experiment = db.session.get(ExperimentModel, experiment_id)

        self.assertEqual(experiment.name, "Exp22")
        self.assertEqual(experiment.parameters, {'stock1_volume': 2000, 'stock2_volume': 1000})

    def test_create_culture(self):
        experiment_id = self.create_model(ExperimentModel, name="Exp22",
                                          parameters={'stock1_volume': 2000, 'stock2_volume': 1000})
        culture_id = self.create_model(Culture, name="Culture1", experiment_id=experiment_id,
                                       parameters={}, active_parameters={})
        # Query for the Culture instance in the database
        with self.app.app_context():
            culture = db.session.get(Culture, culture_id)
        self.assertEqual(culture.name, "Culture1")

if __name__ == '__main__':
    unittest.main()


--- flask_app/tests/simulation_test.py ---
from experiment.ModelBasedCulture.culture_growth_model import CultureGrowthModel, get_simulation_efficiency, culture_growth_model_default_parameters
from experiment.ModelBasedCulture.morbidostat_updater import MorbidostatUpdater, morbidostat_updater_default_parameters

updater = MorbidostatUpdater(**morbidostat_updater_default_parameters)
model = CultureGrowthModel(**culture_growth_model_default_parameters)
model.updater = updater
from experiment.plot import plot_culture

model.simulate_experiment(24)
fig = plot_culture(model)
import plotly.io as pio
pio.show(fig)
print(model.updater.status_dict)
# model.plot_parameters()
# score_updater(model)


--- scripts/update_and_restart_experiment.py ---
import time
import requests
import logging
import subprocess
import threading

# Setup logging with timestamp
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
log_file = logging.FileHandler("logs/update_and_restart.log")
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log_file.setFormatter(formatter)
logger.addHandler(log_file)

current_experiment_id = None
current_experiment_status = None

def get_current_experiment_status():
    url = "http://localhost:5000/experiments/current"
    response = requests.get(url)
    data = response.json()
    if "status" not in data:
        logger.error(f"Error getting experiment status: {data}")
        return None, None
    experiment_status = data["status"]
    experiment_id = data["id"]
    if experiment_status == "running" or experiment_status == "paused":
        global current_experiment_id
        global current_experiment_status
        current_experiment_id = experiment_id
        current_experiment_status = experiment_status
    logger.debug(f"Experiment {experiment_id} is {experiment_status}")
    return experiment_status, experiment_id

def stop_experiment():
    url = "http://localhost:5000/experiments/current/status"
    response = requests.put(url, json={"status": "stopped"})
    print(current_experiment_id)
    logger.debug(f"Stop experiment response: {response.json()}")

def fully_stop_if_running():
    experiment_status, experiment_id = get_current_experiment_status()
    if experiment_status == "running" or experiment_status == "paused":
        logger.info(f"Stopping experiment {experiment_id}")
        stop_experiment()
        time.sleep(2)
        while experiment_status != "stopped":
            experiment_status, experiment_id = get_current_experiment_status()
            time.sleep(2)
            logger.info(f"Experiment {experiment_id} status: {experiment_status}. waiting 2s for it to stop")
        logger.info(f"Experiment {experiment_id} stopped")
    else:
        logger.info("No experiment running")
    return True


def git_pull():
    command = "git reset --hard; git pull"
    logger.debug(f"Running command:\n{command}")
    result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    logger.debug(f"Pull result:\n{result.stdout.decode()}\n{result.stderr.decode()}")


def restart_flask_service():
    command = "ps -eo comm,etime,args | grep flask | grep -v grep | head -n 1 | awk '{print $2}'"
    logger.debug(f"Running command:\n{command}")
    result2 = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    time_running = result2.stdout.decode().strip()
    logger.debug(f"Time flask service running:\n{time_running}")

#     check if systemctl status flask.service is active
    command = "sudo systemctl status flask.service"
    logger.debug(f"Running command:\n{command}")
    result3 = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    logger.debug(f"Systemctl status result:\n{result3.stdout.decode()}\n{result3.stderr.decode()}")
    # check if systemctl status flask.service is active
    if "active (running)" in result3.stdout.decode():
        command = "sudo systemctl restart flask.service"
        logger.debug(f"Running command:\n{command}")
        subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.debug("Flask service restarted")
    time.sleep(5)

    for i in range(10):
        command = "sudo systemctl status flask.service"
        logger.debug(f"Running command:\n{command}")
        result5 = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.debug(f"Systemctl status result:\n{result5.stdout.decode()}\n{result5.stderr.decode()}")
        if "active (running)" in result5.stdout.decode():
            logger.info("Flask service restarted successfully")
            return True
        time.sleep(5)

def flask_backend_is_running():
    url = "http://localhost:5000/experiments"
    for attempt in range(20):
        try:
            response = requests.get(url)
            if response.status_code == 200:
                logger.info("Flask backend is running")
                return True
            logger.warning(f"Flask backend is not running yet, attempt: {attempt + 1}")
        except requests.RequestException as e:
            logger.warning(f"Flask backend is not running yet, attempt: {attempt + 1}. Error: {e}")
        time.sleep(2)

    logger.error("Flask backend is not running after 20 attempts")
    return False


def select_experiment(experiment_id=None):
    if experiment_id is None:
        experiment_id = current_experiment_id
    # check that no experiment is running
    existing_experiment_status, existing_experiment_id = get_current_experiment_status() # should be none after flask service restart
    if existing_experiment_status == "running" or existing_experiment_status == "paused":
        logger.error(f"Experiment {existing_experiment_id} is still running")
        return False
    url = f"http://localhost:5000/experiments/{experiment_id}"
    logger.debug(f"Selecting experiment {experiment_id}")
    response = requests.get(url)
    data = response.json()
    logger.debug(f"Selected experiment {data}")
    time.sleep(1)
    return True


def start_current_experiment():
    url = f"http://localhost:5000/experiments/current/status"
    response = requests.put(url, json={"status": "running"})
    if current_experiment_status == "paused":
        response = requests.put(url, json={"status": "paused"})
        logger.info(f"Resume experiment response: {response.json()}")
    logger.info(f"Start experiment response: {response.json()}")

def update_and_restart():
    git_pull()
    fully_stop_if_running()
    restart_flask_service()
    logger.info("Flask service restarted. Waiting for flask backend to start")
    if flask_backend_is_running():
        logger.info("Flask backend is running. Selecting experiment")
        select_experiment()
        logger.info("Experiment selected. Starting experiment")
        start_current_experiment()
    else:
        logger.error("Flask backend is not running. restarting experiment failed")
    logger.info("Update and restart complete")

if __name__ == "__main__":
    update_and_restart()

--- vue/dist/sphinx/conf.py ---
# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

project = 'replifactory'
copyright = '2023, Catalin Rusnac'
author = 'Catalin Rusnac'

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = []

templates_path = ['_templates']
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']


# -- Options for HTML output -------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

html_theme = 'alabaster'
html_static_path = ['_static']

master_doc = 'index'

--- vue/public/sphinx/conf.py ---
# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

project = 'replifactory'
copyright = '2023, Catalin Rusnac'
author = 'Catalin Rusnac'

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = []

templates_path = ['_templates']
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']


# -- Options for HTML output -------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

html_theme = 'alabaster'
html_static_path = ['_static']

master_doc = 'index'

--- vue/src/server/url_into_sheet.py ---
import json
import time
import socket
import gspread
import requests
from oauth2client.service_account import ServiceAccountCredentials
import os


def get_sheet(spreadsheet_id, sheet_name):
    # use creds to create a client to interact with the Google Drive API
    scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']

    # relative to script dir
    script_dir = os.path.dirname(__file__)
    secrets_file = os.path.join(script_dir, '../../../secrets/googlekey.json')
    creds = ServiceAccountCredentials.from_json_keyfile_name(secrets_file, scope)
    client = gspread.authorize(creds)
    try:
        sheet = client.open_by_key(spreadsheet_id).worksheet(sheet_name)
    except gspread.exceptions.WorksheetNotFound:
        client.open_by_key(spreadsheet_id).add_worksheet(sheet_name, 100, 100)
        sheet = client.open_by_key(spreadsheet_id).worksheet(sheet_name)
    return sheet


def edit_hostname_sheet(spreadsheet_id, sheet_name):
    sheet = get_sheet(spreadsheet_id, sheet_name)
    # get current ip using dev.get_ip()
    url = get_ngrok_url()
    # Update the specified row with the given values
    sheet.update('A1', "IP")
    sheet.update('B1', url)
    sheet.update('A2', "last update")
    sheet.update('B2', time.ctime())

def edit_main_sheet(spreadsheet_id):
    sheet = get_sheet(spreadsheet_id, "main")
    # get current ip using dev.get_ip()
    url = get_ngrok_url()
    # Update the specified row with the given values
#     find row containing hostname in column A. if not exist, add new row
    hostname = socket.gethostname()
    try:
        row = sheet.find(hostname).row
    except Exception as e:
        row = len(sheet.col_values(1)) + 1
        sheet.update(f'A{row}', hostname)
    sheet.update(f'B{row}', time.ctime())
    sheet.update(f'C{row}', url)


def get_ngrok_url():
    try:
        res = requests.get("http://localhost:4040/api/tunnels")
        # Get the JSON data from the response
        res_data = res.json()
        # Get the public URL of the first tunnel
        public_url = res_data["tunnels"][0]["public_url"]
    except Exception as e:
        return str(e)
    return public_url


def write_url_to_google_sheet():
    with open('secrets/googlesheet.json') as f:
        spreadsheet_id = json.load(f)['id']
    hostname = socket.gethostname()
    edit_hostname_sheet(spreadsheet_id, hostname)
    edit_main_sheet(spreadsheet_id)


if __name__ == '__main__':
    write_url_to_google_sheet()

